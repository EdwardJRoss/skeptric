<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.251">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2020-06-26">

<title>skeptric - Extracting Australian Job Postings with SPARQL</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../favicon.ico" rel="icon">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">skeptric</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../about.html">About</a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/EdwardJRoss"><i class="bi bi-github" role="img">
</i> 
 </a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Extracting Australian Job Postings with SPARQL</h1>
  <div class="quarto-categories">
    <div class="quarto-category">jobs</div>
    <div class="quarto-category">commoncrawl</div>
    <div class="quarto-category">rdf</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">June 26, 2020</p>
    </div>
  </div>
    
  </div>
  

</header>

<p>I am trying to extract Australian Job Postings from <a href="http://webdatacommons.org/">Web Data Commons</a> which extracts structured data from <a href="https://commoncrawl.org/">Common Crawl</a>. I have previously written scripts to <a href="../streaming-nquad-rdf">read in the graphs</a>, <a href="../schema-jobposting">explore JobPosting schema</a> and <a href="../sparql-analysing-rdf">analyst the schema using SPARQL</a>. Now we can use these to find some Austrlian Job Postings in the data.</p>
<p>For this analysis I used 15,000 pages containing job postings with different domains from <a href="http://webdatacommons.org/structureddata/2019-12/stats/schema_org_subsets.html">the 2019 Web Data Commons Extract</a>. Here’s the final query that extracts 285 domains; the rest of this article will explain what it’s doing.</p>
<pre class="sparql"><code>PREFIX sdo: &lt;http://schema.org/&gt;
PREFIX sdo_jp: &lt;http://schema.org/JobPosting/&gt;
PREFIX sdo_pl: &lt;http://schema.org/Place/&gt;
PREFIX sdo_pa: &lt;http://schema.org/PostalAddress/&gt;
PREFIX sdo_co: &lt;http://schema.org/Country/&gt;
PREFIX sdo_mv: &lt;http://schema.org/MonetaryValue/&gt;
PREFIX sdos_mv: &lt;https://schema.org/MonetaryValue/&gt;


SELECT distinct ?src
WHERE {
 { 
  GRAPH ?src
  {[] a sdo:JobPosting .}
  BIND (replace(str(?src), 
                'https?://([^?/]+).*',
                '\\1') AS ?domain)
    FILTER (strends(?domain, '.au'))
 }
 UNION
 {
  GRAPH ?src
  {
    {[] a sdo:JobPosting ;
         (sdo:jobLocation|sdo_jp:jobLocation)/
         (sdo:address|sdo_pl:address)/
         (sdo:addressCountry|sdo_pa:addressCountry)/
         ((sdo:name|sdo_co:name)?) ?country .
         FILTER (isliteral(?country) &amp;&amp; 
                 lcase(replace(str(?country),
                               '[ \n\t]*(.*)[ \n\t]*',
                               '\\1')) in ('au', 'australia'))
    }
    UNION
    {[] a sdo:JobPosting ;
        ((sdo:salaryCurrency|sdo_jp:salaryCurrency)|
         (sdo:baseSalary|sdo_jp:baseSalary)/
         (sdo:currency|sdo_mv:currency|sdos_mv:currency)) ?currency .
    BIND (replace(str(?currency), '[ \n\t]+', '') as ?curr)
    FILTER (lcase(?curr) = 'aud')}
  }
 }
}</code></pre>
<section id="finding-australian-domains" class="level1">
<h1>Finding Australian Domains</h1>
<p>The fact there <em>is</em> a URL in the JobPostings extract in Web Data Commons tells you that the URL contains a structured Job Posting. One heuristic for finding Australian job listings is looking for domains ending in <code>.au</code>.</p>
<p>We can get the URL from Common Crawl containing the data by searching for the graph identifier, which we’ll call <code>?src</code>, filtering to graphs containing a JobPosting.</p>
<pre class="sparql"><code>PREFIX sdo: &lt;http://schema.org/&gt;

SELECT ?src
WHERE {
    GRAPH ?src
    {[] a sdo:JobPosting .}
}
LIMIT 10</code></pre>
<p>This gives a list of 10 URLs like <code>https://tire-factory.hiringthing.com/job/17125/warehouse-associate</code>.</p>
<p>We can extract the domain with a regular expression using the <a href="https://www.w3.org/TR/sparql11-query/#func-replace">replace function</a>, and just get results that end in <code>.au</code> using <a href="https://www.w3.org/TR/sparql11-query/#func-strends">strends (string-ends)</a>.</p>
<pre class="sparql"><code>PREFIX sdo: &lt;http://schema.org/&gt;

SELECT DISTINCT ?src
WHERE {
    GRAPH ?src
    {[] a sdo:JobPosting .}
    BIND (replace(str(?src), 'https?://([^?/]+).*', '\\1') AS ?domain)
    FILTER (strends(?domain, '.au'))
}</code></pre>
<p>This gets 233 URLs containing job postings; but we can do a little better if we use the structured data in the job postings.</p>
</section>
<section id="finding-job-postings-located-in-australia" class="level1">
<h1>Finding Job Postings located in Australia</h1>
<p>The <a href="https://schema.org/JobPosting">JobPosting Schema</a> contains a jobLocation, which can be a <a href="https://schema.org/Place">Place</a> which can contain an address, which can be a <a href="https://schema.org/PostalAddress">PostalAddress</a>, which can contain an addressCountry, which can be a <a href="https://schema.org/Country">Country</a> which can have a name. Phew!</p>
<section id="extracting-country-name-with-property-paths" class="level2">
<h2 class="anchored" data-anchor-id="extracting-country-name-with-property-paths">Extracting Country Name with property paths</h2>
<p>We can express this succinctly using SPARQL <a href="https://www.w3.org/TR/sparql11-query/#propertypaths">property paths</a>.</p>
<pre class="sparql"><code>PREFIX sdo: &lt;http://schema.org/&gt;

SELECT ?country (COUNT(distinct ?src) as ?count)
WHERE {
    GRAPH ?src
    {[] a sdo:JobPosting; sdo:jobLocation/sdo:address/sdo:addressCountry/sdo:name ?country .}
}
GROUP BY ?country
ORDER BY DESC(?count)
LIMIT 15</code></pre>
<table class="table">
<thead>
<tr class="header">
<th>Country</th>
<th>count</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>US</td>
<td>127</td>
</tr>
<tr class="even">
<td>CA</td>
<td>20</td>
</tr>
<tr class="odd">
<td>DE</td>
<td>20</td>
</tr>
<tr class="even">
<td>GB</td>
<td>18</td>
</tr>
<tr class="odd">
<td>IL</td>
<td>14</td>
</tr>
</tbody>
</table>
<p>Note that we count distinct graph identifiers; because a page can contain multiple job listings (which in turn can contain multiple jobLocations) it may contribute to multiple countries.</p>
</section>
<section id="extracting-plain-text-addresscountry" class="level2">
<h2 class="anchored" data-anchor-id="extracting-plain-text-addresscountry">Extracting plain text addressCountry</h2>
<p>The addressCountry can also be plain text, and in fact that’s much more common. We can filter out the cases where it’s a structured value (and so <code>?country</code> is a blank node) using <a href="https://www.w3.org/TR/sparql11-query/#func-isLiteral">isLiteral</a>.</p>
<pre class="sparql"><code>PREFIX sdo: &lt;http://schema.org/&gt;

SELECT ?country (COUNT(distinct ?src) AS ?count)
WHERE {
    GRAPH ?src
    {[] a sdo:JobPosting; sdo:jobLocation/sdo:address/sdo:addressCountry ?country .}
    FILTER (isLiteral(?country))
}
GROUP BY ?country
ORDER BY DESC(?count)
LIMIT 10</code></pre>
<p>In the results we can see 86 jobs with AU in the countries.</p>
<table class="table">
<thead>
<tr class="header">
<th>Country</th>
<th>Count</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>United States</td>
<td>385</td>
</tr>
<tr class="even">
<td>JP</td>
<td>358</td>
</tr>
<tr class="odd">
<td>GB</td>
<td>345</td>
</tr>
<tr class="even">
<td>US</td>
<td>320</td>
</tr>
<tr class="odd">
<td>DE</td>
<td>270</td>
</tr>
<tr class="even">
<td>NL</td>
<td>253</td>
</tr>
<tr class="odd">
<td>Deutschland</td>
<td>179</td>
</tr>
<tr class="even">
<td>United Kingdom</td>
<td>139</td>
</tr>
<tr class="odd">
<td>FR</td>
<td>110</td>
</tr>
<tr class="even">
<td>AU</td>
<td>86</td>
</tr>
</tbody>
</table>
</section>
<section id="matching-country-and-text-at-the-same-time" class="level2">
<h2 class="anchored" data-anchor-id="matching-country-and-text-at-the-same-time">Matching Country and text at the same time</h2>
<p>We <em>should</em> be able to combine the two by making <code>name</code> optional with the ZeroOrOnePath operator <code>?</code>.</p>
<pre class="sparql"><code>PREFIX sdo: &lt;http://schema.org/&gt;

SELECT ?country (count(distinct ?src) as ?count)
WHERE {
    GRAPH ?src
    {[] a sdo:JobPosting; sdo:jobLocation/sdo:address/sdo:addressCountry/(sdo:name?) ?country .}
}
GROUP BY ?country
ORDER BY DESC(?total)
LIMIT 15</code></pre>
<p>However for some strange reason we end up with some URIs in the results:</p>
<table class="table">
<thead>
<tr class="header">
<th>Country</th>
<th>Count</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>US</td>
<td>447</td>
</tr>
<tr class="even">
<td>United States</td>
<td>385</td>
</tr>
<tr class="odd">
<td>GB</td>
<td>363</td>
</tr>
<tr class="even">
<td>JP</td>
<td>359</td>
</tr>
<tr class="odd">
<td>DE</td>
<td>290</td>
</tr>
<tr class="even">
<td>NL</td>
<td>257</td>
</tr>
<tr class="odd">
<td>Deutschland</td>
<td>179</td>
</tr>
<tr class="even">
<td>United Kingdom</td>
<td>140</td>
</tr>
<tr class="odd">
<td>FR</td>
<td>116</td>
</tr>
<tr class="even">
<td>AU</td>
<td>91</td>
</tr>
<tr class="odd">
<td>CA</td>
<td>81</td>
</tr>
<tr class="even">
<td>India</td>
<td>60</td>
</tr>
<tr class="odd">
<td></td>
<td>60</td>
</tr>
<tr class="even">
<td>http://schema.org/JobPosting</td>
<td>56</td>
</tr>
<tr class="odd">
<td>http://schema.org/Place</td>
<td>56</td>
</tr>
</tbody>
</table>
<p>Oddly enough this <em>doesn’t</em> happen if we rewrite it as an alternation:</p>
<pre><code>PREFIX sdo: &lt;http://schema.org/&gt;

SELECT ?country (count(?src) as ?total)
WHERE {
    GRAPH ?src
    {[] a sdo:JobPosting; sdo:jobLocation/sdo:address/(sdo:addressCountry|sdo:addressCountry/sdo:name) ?country .}
}
GROUP BY ?country
ORDER BY DESC(?total)
LIMIT 15</code></pre>
<table class="table">
<thead>
<tr class="header">
<th>Country</th>
<th>Total</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>US</td>
<td>609</td>
</tr>
<tr class="even">
<td>JP</td>
<td>444</td>
</tr>
<tr class="odd">
<td>United States</td>
<td>395</td>
</tr>
<tr class="even">
<td>GB</td>
<td>363</td>
</tr>
<tr class="odd">
<td>DE</td>
<td>304</td>
</tr>
<tr class="even">
<td>NL</td>
<td>258</td>
</tr>
<tr class="odd">
<td>Deutschland</td>
<td>179</td>
</tr>
<tr class="even">
<td>United Kingdom</td>
<td>140</td>
</tr>
<tr class="odd">
<td>FR</td>
<td>116</td>
</tr>
<tr class="even">
<td>AU</td>
<td>91</td>
</tr>
<tr class="odd">
<td>CA</td>
<td>84</td>
</tr>
<tr class="even">
<td>India</td>
<td>70</td>
</tr>
<tr class="odd">
<td>Canada</td>
<td>66</td>
</tr>
<tr class="even">
<td></td>
<td>60</td>
</tr>
<tr class="odd">
<td>IN</td>
<td>57</td>
</tr>
</tbody>
</table>
<p>I would expect these to be the same; but I don’t know if my understanding of SPARQL is wrong or it’s a bug in rdflib. When we filter to literal nodes we get the same results, so I’m not going to dwell on it.</p>
</section>
<section id="fully-qualified-paths" class="level2">
<h2 class="anchored" data-anchor-id="fully-qualified-paths">Fully qualified paths</h2>
<p>In the microdata extract the properties are specified by fully qualified paths, for example <code>&lt;http://schema.org/Place/address&gt;</code> instead of just <code>&lt;http://schema.org/address&gt;</code>. So we need to match these patterns too, which means adding a whole heap more prefixes.</p>
<p>We can check the property it’s binding on, but have to be careful to filter out common strings to reduce false positives (e.g.&nbsp;if <code>?country</code> is the empty string then this will extract all properties with an empty string).</p>
<pre class="sparql"><code>PREFIX sdo: &lt;http://schema.org/&gt;
PREFIX sdo_jp: &lt;http://schema.org/JobPosting/&gt;
PREFIX sdo_pl: &lt;http://schema.org/Place/&gt;
PREFIX sdo_pa: &lt;http://schema.org/PostalAddress/&gt;
PREFIX sdo_co: &lt;http://schema.org/Country/&gt;

SELECT ?property (count(distinct ?src) as ?count)
WHERE {
    GRAPH ?src
    {[] a sdo:JobPosting ;
         sdo_jp:jobLocation/sdo_pl:address/sdo_pa:addressCountry/(sdo_co:name?) ?country .
         [] ?property ?country .
         FILTER (isliteral(?country) &amp;&amp;
                (lcase(str(?country)) not in ('', 'na', 'n/a', 'unavailable', ' ', 'null')))
         }
}
GROUP BY ?property
ORDER BY DESC(?count)
LIMIT 10</code></pre>
<p>Having a Country is very rare in microdata, but this looks about right.</p>
<table class="table">
<thead>
<tr class="header">
<th>Property</th>
<th>Count</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>http://schema.org/PostalAddress/addressCountry</td>
<td>1351</td>
</tr>
<tr class="even">
<td>http://schema.org/Country/name</td>
<td>4</td>
</tr>
<tr class="odd">
<td>http://schema.org/PostalAddress/addressLocality</td>
<td>3</td>
</tr>
<tr class="even">
<td>http://schema.org/PostalAddress/streetAddress</td>
<td>1</td>
</tr>
<tr class="odd">
<td>http://schema.org/PostalAddress/addressRegion</td>
<td>1</td>
</tr>
</tbody>
</table>
</section>
<section id="combining-the-patterns" class="level2">
<h2 class="anchored" data-anchor-id="combining-the-patterns">Combining the patterns</h2>
<p>We can combine the two possible schema paths using alternations.</p>
<pre><code>PREFIX sdo: &lt;http://schema.org/&gt;
PREFIX sdo_jp: &lt;http://schema.org/JobPosting/&gt;
PREFIX sdo_pl: &lt;http://schema.org/Place/&gt;
PREFIX sdo_pa: &lt;http://schema.org/PostalAddress/&gt;
PREFIX sdo_co: &lt;http://schema.org/Country/&gt;

SELECT ?country (count(distinct ?src) as ?count)
WHERE {
    GRAPH ?src
    {[] a sdo:JobPosting ;
         (sdo:jobLocation|sdo_jp:jobLocation)/
         (sdo:address|sdo_pl:address)/
         (sdo:addressCountry|sdo_pa:addressCountry)/
         ((sdo:name|sdo_co:name)?) ?country .
         FILTER (isliteral(?country))
         }
}
GROUP BY ?country
ORDER BY DESC(?count)
LIMIT 10</code></pre>
<p>Unfortunately sometimes the country has a language tag and this means the results are treated differently.</p>
<table class="table">
<thead>
<tr class="header">
<th>Country</th>
<th>Count</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>United States (Lang=EN)</td>
<td>469</td>
</tr>
<tr class="even">
<td>US</td>
<td>463</td>
</tr>
<tr class="odd">
<td>United States</td>
<td>393</td>
</tr>
<tr class="even">
<td>GB</td>
<td>365</td>
</tr>
<tr class="odd">
<td>JP</td>
<td>359</td>
</tr>
<tr class="even">
<td>DE</td>
<td>295</td>
</tr>
<tr class="odd">
<td>RU</td>
<td>283</td>
</tr>
<tr class="even">
<td>NL</td>
<td>257</td>
</tr>
<tr class="odd">
<td>Deutschland</td>
<td>186</td>
</tr>
<tr class="even">
<td>United Kingdom</td>
<td>142</td>
</tr>
</tbody>
</table>
<p>We can strip away the language tags by converting it to a plain string with <code>str</code>. Furthermore we can remove any leading/trailing whitespace with a regular expression.</p>
<pre class="sparql"><code>PREFIX sdo: &lt;http://schema.org/&gt;
PREFIX sdo_jp: &lt;http://schema.org/JobPosting/&gt;
PREFIX sdo_pl: &lt;http://schema.org/Place/&gt;
PREFIX sdo_pa: &lt;http://schema.org/PostalAddress/&gt;
PREFIX sdo_co: &lt;http://schema.org/Country/&gt;

SELECT ?countryplain (count(distinct ?src) as ?count)
WHERE {
    GRAPH ?src
    {[] a sdo:JobPosting ;
         (sdo:jobLocation|sdo_jp:jobLocation)/
         (sdo:address|sdo_pl:address)/
         (sdo:addressCountry|sdo_pa:addressCountry)/
         ((sdo:name|sdo_co:name)?) ?country .
         FILTER (isliteral(?country))
         BIND (replace(str(?country), '[ \n\t]*(.*)[ \n\t]*', '\\1') as ?countryplain)
         }
}
GROUP BY ?countryplain
HAVING (COUNT(distinct ?src) &gt;= 50)
ORDER BY DESC(?count)</code></pre>
<p>There’s still some normalisation to do; United States, US and USA are all the same as are DE, Deutschland and Germany.</p>
<table class="table">
<thead>
<tr class="header">
<th>Country</th>
<th>Count</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>United States</td>
<td>863</td>
</tr>
<tr class="even">
<td>US</td>
<td>496</td>
</tr>
<tr class="odd">
<td>GB</td>
<td>381</td>
</tr>
<tr class="even">
<td>JP</td>
<td>362</td>
</tr>
<tr class="odd">
<td>DE</td>
<td>355</td>
</tr>
<tr class="even">
<td>RU</td>
<td>287</td>
</tr>
<tr class="odd">
<td>NL</td>
<td>264</td>
</tr>
<tr class="even">
<td>Deutschland</td>
<td>192</td>
</tr>
<tr class="odd">
<td>United Kingdom</td>
<td>175</td>
</tr>
<tr class="even">
<td>FR</td>
<td>128</td>
</tr>
<tr class="odd">
<td>AU</td>
<td>96</td>
</tr>
<tr class="even">
<td>CA</td>
<td>88</td>
</tr>
<tr class="odd">
<td>India</td>
<td>65</td>
</tr>
<tr class="even">
<td>Canada</td>
<td>61</td>
</tr>
<tr class="odd">
<td></td>
<td>60</td>
</tr>
<tr class="even">
<td>IN</td>
<td>59</td>
</tr>
<tr class="odd">
<td>Germany</td>
<td>50</td>
</tr>
<tr class="even">
<td>USA</td>
<td>50</td>
</tr>
</tbody>
</table>
<p>We find jobs located in Australia looking for the country being ‘AU’ or ‘Australia’ in some case, after trimming whitespace.</p>
<pre><code>PREFIX sdo: &lt;http://schema.org/&gt;
PREFIX sdo_jp: &lt;http://schema.org/JobPosting/&gt;
PREFIX sdo_pl: &lt;http://schema.org/Place/&gt;
PREFIX sdo_pa: &lt;http://schema.org/PostalAddress/&gt;
PREFIX sdo_co: &lt;http://schema.org/Country/&gt;

SELECT DISTINCT ?src
WHERE {
    GRAPH ?src
    {[] a sdo:JobPosting ;
         (sdo:jobLocation|sdo_jp:jobLocation)/
         (sdo:address|sdo_pl:address)/
         (sdo:addressCountry|sdo_pa:addressCountry)/
         ((sdo:name|sdo_co:name)?) ?country .
         FILTER (isliteral(?country) &amp;&amp;
                 lcase(replace(str(?country),
                       '[ \n\t]*(.*)[ \n\t]*', '\\1'))
                 in ('au', 'australia'))
         }
}</code></pre>
<p>This gets 124 URLs, 40 of which don’t end in <code>.au</code>. This includes some New Zealand job sites, some global companies, some talent platforms with company subdomains for Australian companies (<a href="https://breezy.hr/">breezy.hr</a>, <a href="https://www.snaphop.com/">gosnaphot</a> and <a href="https://recruitee.com/en">recruitee</a> and <a href="https://www.jobsindevonport.com/">jobsindevenport.com</a> which is a site dedicated to jobs in the city of Devonport in Tasmania. The majority of these look like Australian job ads.</p>
<p>Note that this means that around half of the jobs in a <code>.au</code> domain don’t have Australia as a country. I’m willing to guess this is because the metadata is incomplete; they probably don’t have an <code>addressCountry</code> property at all.</p>
<p>Another place to look for a location would be <a href="https://schema.org/applicantLocationRequirements">applicantLocationRequirements</a> which is used for remote jobs, but isn’t used much in practice and so doesn’t seem worth investigating.</p>
</section>
</section>
<section id="jobs-paying-australian-dollars" class="level1">
<h1>Jobs paying Australian Dollars</h1>
<p>Australia has it’s own unique currency, the Australian Dollar (AUD). We could try to find Australian jobs by extracting the currency from the job and matching to AUD.</p>
<p>The easiest way is with the <code>salaryCurrency</code> field, removing any lanugage tags as before.</p>
<pre class="sparql"><code>PREFIX sdo: &lt;http://schema.org/&gt;

SELECT ?curr (COUNT(distinct ?src) as ?count)
WHERE {
    GRAPH ?src
    {[] a sdo:JobPosting ;
        sdo:salaryCurrency ?currency .
    }
    BIND (str(?currency) as ?curr)
}
GROUP BY ?curr
ORDER BY DESC(?count)
LIMIT 10</code></pre>
<table class="table">
<thead>
<tr class="header">
<th>Currency</th>
<th>Count</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>GBP</td>
<td>179</td>
</tr>
<tr class="even">
<td>EUR</td>
<td>93</td>
</tr>
<tr class="odd">
<td>USD</td>
<td>69</td>
</tr>
<tr class="even">
<td>€</td>
<td>58</td>
</tr>
<tr class="odd">
<td>AUD</td>
<td>41</td>
</tr>
<tr class="even">
<td>JPY</td>
<td>27</td>
</tr>
<tr class="odd">
<td></td>
<td>13</td>
</tr>
<tr class="even">
<td>円</td>
<td>8</td>
</tr>
<tr class="odd">
<td>INR</td>
<td>7</td>
</tr>
<tr class="even">
<td>HKD</td>
<td>7</td>
</tr>
</tbody>
</table>
<p>Another way the currency can be encoded is as the <code>currency</code> in the <code>baseSalary</code>:</p>
<pre class="sparql"><code>PREFIX sdo: &lt;http://schema.org/&gt;

SELECT ?curr (COUNT(distinct ?src) AS ?count)
WHERE {
    GRAPH ?src
    {[] a sdo:JobPosting ;
        sdo:baseSalary/sdo:currency ?currency .
    }
    BIND (str(?currency) as ?curr)
}
GROUP BY ?curr
ORDER BY DESC(?count)
LIMIT 10</code></pre>
<table class="table">
<thead>
<tr class="header">
<th>Currency</th>
<th>Count</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>GBP</td>
<td>314</td>
</tr>
<tr class="even">
<td>JPY</td>
<td>261</td>
</tr>
<tr class="odd">
<td>USD</td>
<td>234</td>
</tr>
<tr class="even">
<td>EUR</td>
<td>211</td>
</tr>
<tr class="odd">
<td></td>
<td>117</td>
</tr>
<tr class="even">
<td>INR</td>
<td>102</td>
</tr>
<tr class="odd">
<td>JPN</td>
<td>93</td>
</tr>
<tr class="even">
<td>€</td>
<td>62</td>
</tr>
<tr class="odd">
<td>AUD</td>
<td>54</td>
</tr>
<tr class="even">
<td>AFA</td>
<td>23</td>
</tr>
</tbody>
</table>
<section id="combining-all-the-currency-variants" class="level2">
<h2 class="anchored" data-anchor-id="combining-all-the-currency-variants">Combining all the currency variants</h2>
<p>As before we add the fully qualified schemas to get every possible variation. We also add <code>&lt;https://schema.org/MonetaryValue/&gt;</code> because this occurs a few times in practice. In fact the <code>https://schema.org</code> <a href="https://schema.org/docs/faq.html#19">should be equivalent</a> so I should check it everywhere doubling the number of variants. It doesn’t occur much in this dataset, so I mostly ignore it here, but it might become a bigger issue in future.</p>
<pre><code>PREFIX sdo: &lt;http://schema.org/&gt;
PREFIX sdo_jp: &lt;http://schema.org/JobPosting/&gt;
PREFIX sdo_mv: &lt;http://schema.org/MonetaryValue/&gt;
PREFIX sdos_mv: &lt;https://schema.org/MonetaryValue/&gt;


SELECT ?curr (COUNT(distinct ?src) as ?count)
WHERE {
    GRAPH ?src
    {[] a sdo:JobPosting ;
        ((sdo:salaryCurrency|sdo_jp:salaryCurrency)|
         (sdo:baseSalary|sdo_jp:baseSalary)/
          (sdo:currency|sdo_mv:currency|sdos_mv:currency)) ?currency .
    }
    BIND (replace(str(?currency), '[ \n\t]+', '') as ?curr)
    FILTER (!(lcase(?curr) in ('', 'null', 'na', 'n/a', 'unavailable')))
}
GROUP BY ?curr
ORDER BY DESC(?count)
LIMIT 20</code></pre>
<p>The resulting data is pretty good; we could further normalise € as EUR and £ as GBP, but the currencies otherwise look like <a href="https://en.wikipedia.org/wiki/ISO_4217">ISO 4217 currency codes</a>.</p>
<table class="table">
<thead>
<tr class="header">
<th>Currency</th>
<th>Count</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>GBP</td>
<td>392</td>
</tr>
<tr class="even">
<td>USD</td>
<td>302</td>
</tr>
<tr class="odd">
<td>EUR</td>
<td>295</td>
</tr>
<tr class="even">
<td>JPY</td>
<td>266</td>
</tr>
<tr class="odd">
<td>AUD</td>
<td>114</td>
</tr>
<tr class="even">
<td>INR</td>
<td>108</td>
</tr>
<tr class="odd">
<td>JPN</td>
<td>93</td>
</tr>
<tr class="even">
<td>€</td>
<td>68</td>
</tr>
<tr class="odd">
<td>CZK</td>
<td>57</td>
</tr>
<tr class="even">
<td>RUB</td>
<td>50</td>
</tr>
<tr class="odd">
<td>RUR</td>
<td>49</td>
</tr>
<tr class="even">
<td>AFA</td>
<td>23</td>
</tr>
<tr class="odd">
<td>CAD</td>
<td>19</td>
</tr>
<tr class="even">
<td>VND</td>
<td>18</td>
</tr>
<tr class="odd">
<td>HKD</td>
<td>14</td>
</tr>
<tr class="even">
<td>£</td>
<td>14</td>
</tr>
<tr class="odd">
<td>BRL</td>
<td>12</td>
</tr>
<tr class="even">
<td>SEK</td>
<td>11</td>
</tr>
<tr class="odd">
<td>PKR</td>
<td>10</td>
</tr>
<tr class="even">
<td>THB</td>
<td>10</td>
</tr>
</tbody>
</table>
<p>Finally we can filter down to the 114 Job ads offering salary in AUD:</p>
<pre class="sparql"><code>PREFIX sdo: &lt;http://schema.org/&gt;
PREFIX sdo_jp: &lt;http://schema.org/JobPosting/&gt;
PREFIX sdo_mv: &lt;http://schema.org/MonetaryValue/&gt;
PREFIX sdos_mv: &lt;https://schema.org/MonetaryValue/&gt;

SELECT distinct ?src
WHERE {
    GRAPH ?src
    {[] a sdo:JobPosting ;
        ((sdo:salaryCurrency|sdo_jp:salaryCurrency)|
         (sdo:baseSalary|sdo_jp:baseSalary)/(sdo:currency|sdo_mv:currency|sdos_mv:currency)) ?currency .
    }
    BIND (replace(str(?currency), '[ \n\t]+', '') as ?curr)
    FILTER (lcase(?curr) = 'aud')
}</code></pre>
<p>This gives 114 jobs, of which 18 don’t have a <code>.au</code> domain and 12 of those don’t have Australia as a country. Most of these jobs are valid Australian jobs, but for some reason there are a few New Zealand jobs (which <em>should</em> be in NZD).</p>
</section>
</section>
<section id="combining-all-the-results" class="level1">
<h1>Combining all the results</h1>
<p>The query at the start of the article is just the <a href="https://www.w3.org/TR/sparql11-query/#alternatives"><code>UNION</code></a> of the three variants: <code>.au</code> domain, Australia as a country or AUD as the currency.</p>
<p>One catch is that we need to specify the <code>.au</code> in a separate GRAPH query because it filters the domain, which we <em>don’t</em> want to do for country or salary.</p>
<pre class="sparql"><code> { 
  GRAPH ?src
  {[] a sdo:JobPosting .}
  BIND (replace(str(?src), 
                'https?://([^?/]+).*',
                '\\1') AS ?domain)
    FILTER (strends(?domain, '.au'))
 }</code></pre>
<p>But the Country and Salary queries can be done in the same GRAPH search</p>
<pre class="sparql"><code> {
  GRAPH ?src
  {
    {[] a sdo:JobPosting ;
         (sdo:jobLocation|sdo_jp:jobLocation)/
         (sdo:address|sdo_pl:address)/
         (sdo:addressCountry|sdo_pa:addressCountry)/
         ((sdo:name|sdo_co:name)?) ?country .
         FILTER (isliteral(?country) &amp;&amp; 
                 lcase(replace(str(?country),
                               '[ \n\t]*(.*)[ \n\t]*',
                               '\\1')) in ('au', 'australia'))
    }
    UNION
    {[] a sdo:JobPosting ;
        ((sdo:salaryCurrency|sdo_jp:salaryCurrency)|
         (sdo:baseSalary|sdo_jp:baseSalary)/
         (sdo:currency|sdo_mv:currency|sdos_mv:currency)) ?currency .
    BIND (replace(str(?currency), '[ \n\t]+', '') as ?curr)
    FILTER (lcase(?curr) = 'aud')}
  }</code></pre>
<p>You can see the <a href="https://github.com/EdwardJRoss/job-advert-analysis/blob/master/notebooks/Extracting%20Australian%20Job%20Ads%20from%20Web%20Data%20Commons%20with%20SPARQL.ipynb">very similar Jupyter notebook</a> for all the underlying code and analysis.</p>
<p>Now that we have a way of identifying metadata relating to Australian jobs we can start to build them into a pipeline to extract and analyse the data.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>