<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.251">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2020-09-21">

<title>skeptric - Programming Languages to Learn in 2020</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../favicon.ico" rel="icon">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">skeptric</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../about.html">About</a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/EdwardJRoss"><i class="bi bi-github" role="img">
</i> 
 </a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Programming Languages to Learn in 2020</h1>
  <div class="quarto-categories">
    <div class="quarto-category">programming</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">September 21, 2020</p>
    </div>
  </div>
    
  </div>
  

</header>

<blockquote class="blockquote">
<p>A language that doesn’t affect the way you think about programming, is not worth knowing.</p>
<p><a href="http://pu.inf.uni-tuebingen.de/users/klaeren/epigrams.html">Alan Perlis</a></p>
</blockquote>
<p>I spend a lot of time programming in Python and SQL, some time in Bash and R (or at least tidyverse), and a little in Java and Javascript/HTML/CSS. This set of tools is actually pretty versatile about getting things done, but is fairly narrow from a programming concept perspective. Once in a while I think it’s useful to broaden the programming frame to understand different ways of doing things; even if you still stick to the same few languages.</p>
<p>I’ve spent significant time in the past programming in Lua, Scheme, and Clojure and spent some time programming in <a href="https://www.jsoftware.com/">J</a>, Octave/Matlab and ARM Assembly. Each of these languages has contributed to how I think about programming and helps me design programs today. I wanted to reflect a bit on what languages I’d like to learn in the future.</p>
<p>With this in mind my primary goal is <em>learning new ways of thinking</em>, and secondarily ones that have a good community and ecosystem that can solve real problems effectively. I’m not thinking too much about employability, as that changes with language fashion every few years.</p>
<p>Based on some reading I’ve picked a few categories ang languages I would like to learn, and why I picked it over alternatives.</p>
<ul>
<li>Typed Functional: F#</li>
<li>Concurrent: Elixir</li>
<li>Efficient: C</li>
<li>Search: ???</li>
</ul>
<section id="typed-functional-language-f" class="level1">
<h1>Typed Functional Language: F</h1>
<p>Typed functional languages claim to be very robust. It’s really easy to make code that works most of the time but then fails in obscure ways on edge cases (as I’ve learned well in Bash and PHP). Typed functional languages prevent a lot of categories of error through composing simple pure functions and statically verifying that the functions fit together and every alternative is handled (and not forgotten).</p>
<p>They have much richer types, and ways of creating types, than a language like Java that remove a lot of the boilerplate and allow more expressive code. Immutability reduces the amount of state complexity and makes them easier to test (without extensive mocking). Because of the static type checking they claim to be much easier to safely refactor than languages like Clojure.</p>
<p>I’m picking F# because it looks interesting and quite different from what I know. It’s learned a lot of lessons from OCaml and built on top of it. It seems quite elegant, and has access to lots of useful libraries from .NET (though I have heard rapid changes to .NET can make for painful transitions).</p>
<section id="resources" class="level2">
<h2 class="anchored" data-anchor-id="resources">Resources</h2>
<p>There are a <a href="https://fsharp.org/learn/">lot of F# resources</a>, but I’m particularly interested in <a href="https://fsharpforfunandprofit.com/books/">Domain Modeling Made Functional</a> from <a href="https://fsharpforfunandprofit.com">F# for Fun and Profit</a>. This sounds like a great resource for a way of thinking of how to design programs and implementing it in F#.</p>
</section>
<section id="alternatives" class="level2">
<h2 class="anchored" data-anchor-id="alternatives">Alternatives</h2>
<ul>
<li>OCaml, which is similar to F#, but since F# came later (and learned some lessons) and has access to .NET libraries it seems to me a better choice to start.</li>
<li>Haskell, which I have some passing experience with, but I’ve feel like you end up jumping through monadic hoops for the sake of purity (maybe it’s worthwhile; I’m yet to be convinced).</li>
<li>Scala but it seems a bit more multiparadigm and to learn new concepts F# seems like a better choice.</li>
</ul>
<p>These are all interesting languages I’d like to learn more about; but I’d start with F#.</p>
</section>
</section>
<section id="concurrent-language-elixir" class="level1">
<h1>Concurrent Language: Elixir</h1>
<p>I spend a lot of time programming in Python, but the GIL and library support makes concurrency programming painful. But being able to have lots of lightweight concurrent operations is really useful for some kinds of applications, especially APIs.</p>
<p>I’m really interested in Elixir because it’s built on BEAM, the library for Erlang. Erlang has a reputation for building robust distributed systems (in fact built by Ericsson for telecommunications) by having lightweight actors that robustly define how they handle communication errors. This sounds like a totally different way of thinking very useful for programming distributed systems.</p>
<section id="resources-1" class="level2">
<h2 class="anchored" data-anchor-id="resources-1">Resources</h2>
<p>From the <a href="https://elixirforum.com/t/which-book-to-read/16485/4">Elixir Forum</a> it sounds like <a href="https://www.manning.com/books/elixir-in-action-second-edition">Elixir in Action</a> and <a href="https://pragprog.com/titles/elixir16/programming-elixir-1-6/">Programming Elixir</a> are good resources. I’ll have to research more deeply here.</p>
</section>
<section id="alternatives-1" class="level2">
<h2 class="anchored" data-anchor-id="alternatives-1">Alternatives</h2>
<ul>
<li>Erlang is the language that Elixir is built on, but it abstracts a lot of the syntactic sugar away. <a href="https://learnyousomeerlang.com/">Learn You Some Erlang</a> is meant to be a great resource for both.</li>
<li>Go allows a lot of concurrency through Goroutines, and has tiny cross-platform binaries, but I don’t think I’d learn as much about resilience.</li>
<li>Node.JS allows a lot of asynchronous work through callbacks, but I’m not really convinced that this style is easy to program in.</li>
</ul>
</section>
</section>
<section id="efficient-c" class="level1">
<h1>Efficient: C</h1>
<p>Sometimes you want a low level language for performance, or to access low level systems. Building a very basic Operating System on a Raspberry Pi through the <a href="https://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/os/">Baking Pi Tutorial</a> made me think much more about how things really go on at a system level.</p>
<p>C is <em>the</em> systems programming language. A <em>lot</em> of useful code is written in C, like the Linux Kernel, and knowing a bit about C lets you customise this software and write fast things yourself. It also shares a lot of culture with C++, which is another widely used language, but is a lot harder to start with.</p>
<section id="resources-2" class="level2">
<h2 class="anchored" data-anchor-id="resources-2">Resources</h2>
<p>I’ve read a lot that K&amp;R C is the place to start. It may not cover modern C, but gets across a lot of the initial philosophy and structure.</p>
</section>
<section id="alternatives-2" class="level2">
<h2 class="anchored" data-anchor-id="alternatives-2">Alternatives</h2>
<ul>
<li>C++ is what most low-level numeric code is implemented in and is a very useful thing to understand. It’s also got a reputation for being huge and complex and taking a long time to learn. I would go here after learning C.</li>
<li>Rust sounds like it fixes a lot of the hard problems especially in C++ that lead to security vulnerabilities, while remaining low level and fast. But it’s not as widely used yet, and to me it makes more sense to start with C++ before learning C.</li>
<li>Julia claims to be very fast for numeric calculations, and takes a different approach to Python and R. The ecosystem is building (especially through interfacing with R and Python) and is one to watch. I’ve heard that by design it has great language interoperability.</li>
<li>Swift is really interesting in building atomically on LLVM. As a fan of Scheme I really like how it builds from LLVM primitives (e.g.&nbsp;see implementations of <a href="https://github.com/apple/swift/blob/master/stdlib/public/core/Bool.swift#L245">bool</a>, and it’s useful for building iOS applications. One worth learning.</li>
</ul>
<p>These all sound really interesting to me - if only there was more time.</p>
</section>
</section>
<section id="search-languages" class="level1">
<h1>Search Languages: ???</h1>
<p>I really like the idea of the computer doing the hard work of solving a problem rather than me telling it how to solve it. Search approaches are useful for this, but I’m not really sure what I’d pick here. Some interesting logic programming languages are:</p>
<ul>
<li>Prolog: The most famous logic programming language. Can implement many interesting algorithms</li>
<li><a href="https://mercurylang.org/">Mercury</a>: Functional logic language; a little immature</li>
<li><a href="https://en.wikipedia.org/wiki/MiniKanren">Minikanren</a>: A way of embedding logic programming in languages</li>
<li>Datalog: A logic query language, a sort of alternative to SQL</li>
</ul>
<p>But there are other types of search techniques:</p>
<ul>
<li>Constraint Programming in <a href="https://www.minizinc.org/">MiniZinc</a>: Describing how to solve problems as optimisation under constraints. I’m also interested in the <a href="https://www.coursera.org/learn/discrete-optimization">Discrete Optimisation</a> covering some of these methods.</li>
<li><a href="https://github.com/Z3Prover/z3">Z3 Theorem Prover</a>: An SMT Solver</li>
<li><a href="https://en.wikipedia.org/wiki/Simulated_annealing">Simulated Annealing</a>: An effective optimisation method for certain problems</li>
<li>Proof Assistants: Like Coq, Agda and Idris</li>
</ul>
<p>These are all things I’m interested in, but don’t know enough about. But I feel like one day I’ll hit a problem (or I already have) that would be easy if only I knew them better.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>