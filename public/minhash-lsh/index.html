<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.251">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2020-05-10">

<title>skeptric - Searching for Near Duplicates with Minhash</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../favicon.ico" rel="icon">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">skeptric</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../about.html">About</a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/EdwardJRoss"><i class="bi bi-github" role="img">
</i> 
 </a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Searching for Near Duplicates with Minhash</h1>
  <div class="quarto-categories">
    <div class="quarto-category">nlp</div>
    <div class="quarto-category">jobs</div>
    <div class="quarto-category">python</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">May 10, 2020</p>
    </div>
  </div>
    
  </div>
  

</header>

<p>I’m trying to find near duplicates texts in the <a href="https://www.kaggle.com/c/job-salary-prediction">Adzuna Job Salary Predictions Kaggle Competition</a>. In the last article I <a href="../minhash">built a collection of MinHashes</a> of the 400,000 job ads in half an hour in a 200MB file. Now I need to efficiently search through these minhashes to find the near duplicates because brute force search through them would take a couple of days on my laptop.</p>
<p>MinHash was designed to approach this problem as outlined in the <a href="../resources/broder97resemblance.pdf">original paper</a>. Finding <a href="../exact-duplicates">exact duplicates</a> was easy because we were checking for equality. If we had a new duplicate document we could use a hash table to quickly see if we had already seen it. Similarly here we group our MinHashes into <em>bands</em> that we store in a hash table to find collisions. The details are covered well in <a href="http://www.mmds.org/">Chapter 3 of Mining Massive Datasets by Ullman et al.</a> and <a href="https://www.amazon.com/Probabilistic-Data-Structures-Algorithms-Applications/dp/3748190484">chapter 6 of Gakhov’s Probabilistic Data Structures and Algorithms for Big Data Applicatoins</a>.</p>
<p>This approach of putting similar things in the same bucket is called <a href="https://en.wikipedia.org/wiki/Locality-sensitive_hashing">Locality Sensitive Hashing (LSH)</a>. There are a <a href="https://arxiv.org/abs/1408.2927">whole family</a> of these for different distances, such as bit-sampling for <a href="https://en.wikipedia.org/wiki/Hamming_distance">Hamming Distance</a> and <a href="https://en.wikipedia.org/wiki/SimHash">SimHash</a> for <a href="https://en.wikipedia.org/wiki/Cosine_similarity">Cosine Distance</a>.</p>
<p>LSH can work really well as an online algorithm to efficiently check for near-duplicates in a large corpus, by storing and adding to these band hash tables.</p>
<section id="picking-bands-and-rows-the-s-curve" class="level1">
<h1>Picking bands and rows: The S-curve</h1>
<p>We have some fixed number of hashes and need to group them into bands of equal rows for LSH. The way we group them changes the sensitivity. Having few bands with many rows will only get collisions between pairs with a very high Jaccard similarity. Having many bands with few rows will get collisions between pairs with a very low Jaccard similarity.</p>
<p>We use our hashes to create <em>b</em> bands each containing <em>r</em> rows (where their product is at most the number of hashes). We then collect all items that have the same hash accross all <em>r</em> rows for any band, which is a simple lookup. This can be used to get the probability a pair will occur in the same band:</p>
<ul>
<li>The probability that a given row is the same is the Jaccard similarity <em>s</em> (as discussed in the <a href="../minhash">previous article on MinHash</a>)</li>
<li>The probability that a given band of <em>r</em> rows agree is <span class="math inline">\(s^r\)</span>, because they are each independent</li>
<li>The probability that a given band of <em>r</em> rows do not agree is <span class="math inline">\(1 - s^r\)</span></li>
<li>The probability that the <em>r</em> rows don’t agree for any of the <em>b</em> bands is <span class="math inline">\((1 - s^r)^b\)</span> because they are independent</li>
<li>The probability that the <em>r</em> rows agree for at least one of the <em>b</em> bands is <span class="math inline">\(1 - (1 - s^r)^b\)</span></li>
</ul>
<p>This curve is a high-pass filter and it looks a bit like an “S”, so we call it an S curve.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../images/s-curve-16.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">Example S-curve with 16 bands of 16 rows</figcaption><p></p>
</figure>
</div>
<p>We need to tune our number of rows and bands to capture the pairs with similarity we want and exclude the pairs we don’t want. We can always post-process to exclude false positives with low similarity (by calculating the exact similarity), but any false negatives can’t be recovered. However since there are typically orders of magnitude more pairs with low similarity we need the probability to be very very low for the calculation to be tractable.</p>
<section id="analysis-of-the-s-curve" class="level2">
<h2 class="anchored" data-anchor-id="analysis-of-the-s-curve">Analysis of the S-Curve</h2>
<p>A little calculus helps understand how the parameters affect the shape of the curve. The probability of emission from the LSH as a function of similarity s is <span class="math inline">\(P(s) = 1 - (1 - s^r) ^ b\)</span>. The slope of this curve is <span class="math inline">\(P^\prime(s) = r b (1 - s^r)^(b-1) * s ^ {r - 1}\)</span>, which is always increasing. This means the curve is a good high pass filter.</p>
<p>Calculating where the second derivative is zero gives the curve is steepest at <span class="math inline">\(\sqrt[r]{\frac{1 - \frac{1}{r}}{b - \frac{1}{r}}}\)</span>. We’ll call this point the <em>threshold</em> of the curve, because it’s close to where it starts letting in values. This is approximately <span class="math inline">\(\hat{s} = \sqrt[r]{\frac{1}{b}}\)</span>, and the approximation is better for larger <em>r</em>. For <em>b</em> and <em>r</em> larger than about 4 the probability at the threshold is <span class="math inline">\(1 - e ^ {-1} \approx 0.6\)</span>, so it is close to the midpoint between accepting and rejecting. The slope at this point is around <span class="math inline">\(\frac{r} {e \hat{s}}\)</span>, which gives a first-order width of the <em>s</em>.</p>
<p>The upshot of all this is that if you double the number of rows and square the number of bands you get the same threshold with approximately half the width. Because the total number of hash functions required is the product of the number of bands and rows, it gets expensive to decrease the width because the bands required is large. It’s also easier to make sharp cutoffs for relatively large thresholds.</p>
</section>
<section id="choosing-a-practical-cutoff" class="level2">
<h2 class="anchored" data-anchor-id="choosing-a-practical-cutoff">Choosing a practical cutoff</h2>
<p>Given that we have 128 permutations how do we choose the cutoff? We need to pick <em>r</em> and <em>b</em> with a product at most 128 (so for example 16 and 8 would do, as would 5 and 25).</p>
<p>Because we can always filter out false negatives but can’t retrieve false positives the target should be to remove the bulk of texts with a very small overlap. When we <a href="../jaccard-duplicates">looked at the 4-Jaccard near duplicates</a> they were similar above about 0.5, and very different below 0.05, so we want to capture this threshold. So ideally for ads with a similarity below 0.05 there should be a very small chance (say 0.1%) that they get included and for ads with similarity about 0.5 there should be a high chance (say 99%) that they are included.</p>
<p>Looking some different values for <em>b</em> and <em>r</em> shows the tradeoffs:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../images/minhash_s_128.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">Different bands and r</figcaption><p></p>
</figure>
</div>
<p>The best solution seems to be 42 bands of 3 rows. At 0.5 it’s got a 99.6% probability of inclusion, and at 0.05 it has a .5% chance of inclusion.</p>
</section>
<section id="dont-use-threshold-in-datasketch" class="level2">
<h2 class="anchored" data-anchor-id="dont-use-threshold-in-datasketch">Don’t use threshold in DataSketch</h2>
<p>The <a href="http://ekzhu.com/datasketch/index.html">datasketch library</a> provides an argument for <code>threshold</code> for the <a href="http://ekzhu.com/datasketch/documentation.html#datasketch.MinHashLSH">MinHashLSH</a>. It uses a deeply flawed way to try to calculate this. It tries estimate the error by <a href="https://github.com/ekzhu/datasketch/blob/8274ebec58f04fb96347fc4fa568f1913c25ae38/datasketch/lsh.py#L30"><em>integrating</em></a> the S-curve, which doesn’t make sense because it isn’t a probability denisty. If the integral was divided by the length of the interval it would be the average probability over the interval, but as it is I’m not sure how to interpret this quantity.</p>
<p>I raised an <a href="https://github.com/ekzhu/datasketch/issues/129">issue</a> about this, but I closed it because:</p>
<ul>
<li>Existing users have probably tuned the threshold and depend on the behaviour</li>
<li>I can’t think of a way to implement the existing interface with weights (unless they’re deprecated)</li>
<li>There’s no clear choice for the threshold; the value <code>(1/b)**(1/r)</code> is a reasonable candidate, but it has a different meaning to the API</li>
<li>You can work around it by passing the number of bands and rows as a tuple into <code>params</code></li>
<li>I found it difficult to communicate my argument (but I’m <em>pretty</em> sure it doesn’t make sense)</li>
</ul>
<p>In practice it makes sense to tune the curve based on the value where the S-curve goes below ~0.1% or above 99% which is straightforward with a root finder, and just pass in these parameters.</p>
</section>
</section>
<section id="implementation" class="level1">
<h1>Implementation</h1>
<p>I’m continuing to use the <a href="http://ekzhu.com/datasketch/index.html">datasketch library</a> for finding near duplicates.</p>
<p>We can then use <a href="http://ekzhu.com/datasketch/documentation.html#datasketch.MinHashLSH"><code>MinHashLSH</code></a> to find all items with approximate Jaccard distance, passing in the The underlying library lets you tune the tradeoff between false-positives and false-negatives with weights, but I’ll use the default of equal weights. To ensure we only get each pair once for each item we first search for nearby items with <code>query</code> and then add it to the collection with <code>insert</code>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> lsh_similar(minhashes, bands, rows):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    lsh <span class="op">=</span> MinHashLSH(num_perm<span class="op">=</span>num_perm, params<span class="op">=</span>(bands, rows))</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, mh <span class="kw">in</span> <span class="bu">enumerate</span>(tqdm(minhashes)):</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Check if duplicate of already seen item</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> lsh.query(mh):</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">yield</span> (j, i)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Add to the seen items</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        lsh.insert(i, mh)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>I visualise this as walking accross the upper-triangle of the matrix of all pairs; in the first column there’s nothing to check, in the second column you just need to check the first row, in the third column you need to check the first two rows. You’ve got every possible pair one; because the matrix of distances is symmetric and zero along the diagonal you know all the information. This does mean the approach is quadratic in time, but you could store the state of the LSH (so you don’t need to regenerate it every time) and even use it for online processing.</p>
<p>It’s possible to directly walk the buckets using <code>lsh.hashtables</code>; I’ll discuss that more in the next part.</p>
<p>For the 400,000 job ad pairs it takes 15 minutes to get all pairs with 42 bands of 3 rows, yielding around 7 million pairs, which is much smaller than the full 80 billion possible pairs!</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>similar_all <span class="op">=</span> <span class="bu">list</span>(lsh_similar(minhashes, <span class="dv">42</span>, <span class="dv">3</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>If we look at the frequency of results against the 3-Shingle Jaccard Similarity we see there’s a spike around 0.25 near the threshold of the S-curve (the S-curve has been overlaid in orange). This is to be expected as the number of pairs grows very steeply with decreasing similarity. There’s a small spike near 0 where the probability is very low, but the number of pairs is quite large.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../images/minhash_lsh_frequency.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">Frequency of LSH pairs by 3-Jaccard Similarity</figcaption><p></p>
</figure>
</div>
<p>Now we have the pairs we need to work out how to interpret and use them. If you want to produce S-curve plots, these were produced using <a href="../resources/minhash_s_curves.R">this R script</a>.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>