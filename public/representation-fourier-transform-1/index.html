<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.251">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2011-06-29">

<title>skeptric - Linear representation of additive groups and the Fourier Transform: Part 1</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../favicon.ico" rel="icon">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">skeptric</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../about.html">About</a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/EdwardJRoss"><i class="bi bi-github" role="img">
</i> 
 </a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Linear representation of additive groups and the Fourier Transform: Part 1</h1>
</div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">June 29, 2011</p>
    </div>
  </div>
    
  </div>
  

</header>

<p>In this article I will show that the cyclic group of order n, that is the set <span class="math inline">\(\{0,1,2,\ldots,n-1\}\)</span> under addition modulo n motivates the discrete Fourier transform on a particular finite dimensional complex inner product space, and gives many of its properties. In a subsequent article I will extend this to the general Fourier transform and its relation to the group of integers and real numbers under addition.</p>
<!--more-->
<p>To begin I want to consider linear representations of the cyclic group of order n: that is I want to assign to each element of the group a linear operator on an inner product space in a way consistent with the group structure [or if you prefer, to find a homomorphism from the cyclic group to the group of automorphisms of an inner product space (an orthogonal group)]. There are lots of ways to do this, for lots of different vector spaces – the simplest is to map every group element to the identity (the <em>trivial (linear) representation</em>).</p>
<p>It would be nice to have some sort of canonical linear representation. Given a set we can form a vector space by taking all formal linear combinations of its elements (that is we consider the elements of the set to be linearly independent vectors, and the vector space is their span). If a group acts on that set we can extend it to a linear representation of the induced vector space by extending the group linearly; this is called the <strong>permutation representation</strong>.</p>
<p>For example if the set is <span class="math inline">\(\{a,b,c\}\)</span> the vector space is three dimensional and consists of all elements of the form <span class="math inline">\(\{x_a a + x_b b + x_c c| x_a,x_b,x_c \in \mathbb{C}\}\)</span> . The group of all permutations on three elements acts on the set, and given such a permutation <span class="math inline">\(\sigma: \{a,b,c\} \to \{a,b,c\}\)</span> it is represented by the linear mapping <span class="math inline">\(x_a a + x_b b + x_c c \to x_a \sigma(a) + x_b \sigma(b) + x_c \sigma(c)\)</span> .</p>
<p>Now the group G acts on the set G by left multiplication, and so we can construct a permutation representation. This is called the <strong>regular representation</strong> of G.</p>
<p>What does this look like for a cyclic group of order n? The vector space has a basis of <span class="math inline">\(\{e_0,e_1,e_2,\ldots,e_{n-1}\}\)</span> , and the group element 1 is represented by the linear transformation S satisfying <span class="math inline">\(Se_i=e_{i+1}\)</span> (where addition is modulo n). The group element k=1+1+…+1 is represented by <span class="math inline">\(S^k=SS\cdots S\)</span> .</p>
<p>There is also a natural inner product <span class="math inline">\((e_i,e_j) = \delta_{i,j}\)</span> and this is invariant under S (that is S is unitary). As a matrix <span class="math inline">\(S=\begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; \ldots &amp; 0 &amp; 1\\ 1 &amp; 0 &amp; 0 &amp; \ldots &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0 &amp; \ldots &amp; 0 &amp; 0\\ \vdots &amp;\vdots &amp;\vdots &amp; \ddots &amp;\vdots &amp;\vdots\\ 0 &amp; 0 &amp; 0 &amp; \ldots &amp; 1 &amp; 0\end{bmatrix}\)</span> .</p>
<p>Now since S is unitary it is normal and hence by the spectral theorem unitarily diagonalisable. So let’s look for it’s eigenvectors and eigenvalues: since <span class="math inline">\(S^n = I\)</span> it’s clear its eigenvalues must be nth roots of unity, so denote <span class="math inline">\(\omega = \exp{2\pi i/n}\)</span> (the choice of sign, and to some extent root, is arbitrary). We can in fact easily see that <span class="math inline">\(v_k = (e_0 + \omega^{-k} e_1 + \omega^{-2k} e_2 + \ldots \omega^{-(n-1)k} e_{n-1})/\sqrt{n}\)</span> is a normalised eigenvector of S with eigenvalue <span class="math inline">\(\omega^{k}\)</span> (go on, check it!). Actually the normalised eigenvectors are only determined up to an overall phase, so <span class="math inline">\(v'_k=e^{i \phi_k} v_k\)</span> would work equally well, but I’ll stick to these phase conventions for convenience.</p>
<p>The diagonalising matrix is then <span class="math inline">\(F= \frac{1}{\sqrt{n}}\begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; \ldots &amp; 1 \\ 1 &amp; \omega &amp; \omega^2 &amp; \ldots &amp; \omega^{n-1} \\ 1 &amp; \omega^2 &amp; \omega^4 &amp; \ldots &amp; \omega^{2(n-1)}\\ \vdots &amp;\vdots &amp;\vdots &amp; \ddots &amp;\vdots\\ 1 &amp; \omega^{n-1} &amp; \omega^{2(n-1)} &amp; \ldots &amp; \omega^{(n-1)(n-1)}\end{bmatrix}\)</span> .</p>
<p>So <span class="math inline">\(F^\dagger S F = \mathrm{diag} (1,\omega,\omega^2,\ldots,\omega^{n-1})\)</span> . In fact F diagonalises every group element by multiplication: <span class="math inline">\(F^{\dagger} S^k F = (F^{\dagger} S F)^k = \mathrm{diag}(1,\omega^k,\omega^{2k},\ldots,\omega^{(n-1)k})\)</span></p>
<p>F is precisely the <a href="http://en.wikipedia.org/wiki/Discrete_Fourier_transform#Definition">discrete Fourier transform</a> (up to a choice of normalisation): if <span class="math inline">\(v=\sum_{j=0}^{n-1} v^n e_n\)</span> , then <span class="math inline">\(F(v) = \frac{1}{\sqrt{n}}\sum_{j,k=0}^{n-1} e^{(-2\pi i/n) j k} v^j e_{k}\)</span> .</p>
<p>Many of the <a href="http://en.wikipedia.org/wiki/Discrete_Fourier_transform#Properties">properties</a> of the discrete Fourier transform follow immediately; we know it is unitary by the spectral theorem which is precisely the Plancherel theorem. In particular it is invertible, which gives completeness. One half of the shift theorem is also immediate <span class="math inline">\(FS^k = F S^k F^\dagger F = (F^{\dagger} S^{-k} F) F = \mathrm{diag} (1,\omega^{-k},\omega^{-2k},\ldots,\omega^{-(n-1)k}) F\)</span> . One can see from the explicit form for F that <span class="math inline">\(F(e_i)=F^{\dagger} (e_{-i})\)</span> and so if we define the operator <span class="math inline">\(N e_i = e_{-i}\)</span> then <span class="math inline">\(F^2=F F = F F^{\dagger} N = N\)</span> (though this would be different if we had chosen a different normalisation condition), so applying F to the half of the shift theorem above gives the other half (is there an easier way to see this?).</p>
<p>What about convolutions? Given that each basis vector corresponds to a group element, there is a natural algebraic structure on the vector space, namely <span class="math inline">\(e_i \otimes e_j = e_{(i+j)}\)</span> (where as usual addition is modulo n). This is precisely a convolution; Excercise: by requiring <span class="math inline">\(\otimes\)</span> to be distributive and expanding in component prove <span class="math inline">\(v \otimes w = \sum_{j=0}^{n-1} \sum_{k=0}^{n-1} v^k w^{j-k} e_j\)</span> . What about the convolution theorem? Well we don’t really have an idea of a multiplicative structure (yet) so it doesn’t really make sense.</p>
<p>What is the exact structure on V? There’s an inner product, but there’s also a <strong>relative ordering</strong> of the basis elements; it doesn’t matter where we start numbering the basis elements (except in the definition of convolutions) but S defines an order for them relative to each other. So to say the Fourier transform is defined by a complex inner product space is lying a little, because there is this extra structure. [Also, considering the Fourier transform is only defined up to a phase it could be more natural to think of two vectors being equivalent if they differ only by a phase.] Actually there is a much more natural way to introduce this structure.</p>
<p>There is another way to think of a permutation representation. We form the vector space associated to a set as the vector space of all linear functions from the set to the complex numbers. The basis vector corresponding to the element s is the characteristic function of s, <span class="math inline">\(\delta_s: S \to \mathbb{C}\)</span> which maps s to 1 and every other element to 0. (Exercise: Show this is equivalent to the description given before, at least if the set is finite). An arbitrary function can be decomposed into the basis of characteristic functions: <span class="math inline">\(f = \sum_{s \in S} f(s) \delta_s\)</span> . The action of a group element is <span class="math inline">\((g \circ f) (s) = \sum_{t \in S} f(t) \delta_{g \circ t} (s) = \sum_{t \in S} f(t) \delta_{t} (g^{-1} \circ s) = f(g^{-1} \circ s)\)</span> .</p>
<p>Now let’s look back at the regular representation of the cyclic group through this lens. We consider functions <span class="math inline">\(f:\mathbb{Z}/n \to \mathbb{C}\)</span> , with the inner product <span class="math inline">\((f,g) = \sum_{m=0}^{n-1} f(m)g(m)\)</span> and we have the shift operator <span class="math inline">\(S \in \mathrm{Aut}(\mathrm{Map}(\mathbb{Z}/n,\mathbb{C}))\)</span> given by <span class="math inline">\((Sf)(m)=f(m-1)\)</span> . The Discrete Fourier Transform is given by <span class="math inline">\((Ff)(m) = \frac{1}{\sqrt{n}} \sum_{k=0}^{n-1} f(k) e^{-(2 \pi i/n) m k}\)</span> . The diagonalisation property is that <span class="math inline">\(F^\dagger S F\)</span> is a multiplicative operator, equivalent to pointwise multiplication by the function <span class="math inline">\(\hat{S}(m)=e^{2\pi i m/n}\)</span> . (Indeed <a href="http://www.math.wsu.edu/faculty/watkins/Math502/pdfiles/spectral.pdf">Halmos notes</a> that any normal operator can be unitarily mapped to a multiplicative operator is one way of viewing the spectral theorem).</p>
<p>A convolution is then <span class="math inline">\((f \otimes g)(m) = \sum_{k=0}^{n-1} f(k) g(m-k)\)</span> . Now taking the Fourier transform of a convolution of basis elements <span class="math inline">\(F(\delta_j \otimes \delta_k) = F(\delta_{j+k}) = \sum_{l=1}^{n} \omega^{-(j+k)l}\delta_l\)</span> , and using that the pointwise product <span class="math inline">\(\delta_l \delta_m = \delta^l_m \delta_l\)</span> (no sum) means we can rewrite it as <span class="math inline">\(\sum_{l=1}^{n} \sum_{m=1}^{n} \omega^{-jl} \delta_l \omega^{-km} \delta_m\)</span> that is <span class="math inline">\(F(\delta_j \otimes \delta_k) = F(\delta_j) F(\delta_k)\)</span> . Applying linearity gives one half of the convolution theorem: <span class="math inline">\(F(f \otimes g) = F(f) F(g)\)</span> . The other half is readily obtained using <span class="math inline">\(F^2=N\)</span> . Thus the Fourier transform maps the additional ring structure given by pointwise multiplication to the convolution structure given by the regular representation.</p>
<p>So what have we got? We started looking at regular linear representations of the cyclic group, and to change to a basis in which the group operations were diagonal we invented the discrete Fourier transform.</p>
<p>The power in this idea is there are many generalisations. We could have a look at more complicated groups or even more general algebraic structures. The representation theory of cyclic groups is very simple since they are abelian, there’s a lot more involved in trying to diagonalize the representations of non-abelian groups. We could then have other notions of convolutions and Fourier-type transforms. We could also look at mapping to other vector spaces or even to different geometric structures. If instead of constructing vector spaces over the complex numbers we constructed it over finite fields we would get (for the right combination of dimension of the vector space and characteristic of the field) the finite Fourier transform which is important in coding theory. One could also look at what happens to direct sums, tensor products and the like of the regular representations.</p>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>