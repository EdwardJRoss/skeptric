<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.251">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2020-08-09">

<title>skeptric - Finding Australian Locations with Placeholder</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../favicon.ico" rel="icon">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">skeptric</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../about.html">About</a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/EdwardJRoss"><i class="bi bi-github" role="img">
</i> 
 </a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Finding Australian Locations with Placeholder</h1>
  <div class="quarto-categories">
    <div class="quarto-category">python</div>
    <div class="quarto-category">nlp</div>
    <div class="quarto-category">jobs</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">August 9, 2020</p>
    </div>
  </div>
    
  </div>
  

</header>

<p>People write locations in many different ways. This makes them really hard to analyse, so we need a way to normalise them. I’ve already discussed how <a href="https://github.com/pelias/placeholder">Placeholder</a> is <a href="../coarse-geocoding">useful for coarse geocoding</a>. Now I’m trying to apply it to normalising locations from <a href="../common-crawl-job-ads">Australian Job Ads in Common Crawl</a>.</p>
<p>The best practices when using Placeholder are:</p>
<ul>
<li>Go from the most specific location information (e.g.&nbsp;street address) to the most general (e.g.&nbsp;country)</li>
<li>Separate different parts of location information with commas</li>
<li>Provide as much context as possible, for example adding the country when known</li>
<li>When the country is known filter the results using the lineage</li>
<li>Use the place types relevant to the problem and region</li>
</ul>
<section id="whos-on-first" class="level1">
<h1>Who’s on First?</h1>
<p>I really only want to know roughly where the advertised jobs are located. This can be a very complicated question for jobs that involve multiple sites, or are primarily visiting clients, or fully remote jobs. However a rough location is a useful concept and jobs in Adelaide are different to jobs in Sydney.</p>
<p>The simplest solution for this is matching text from a gazetteer. For example you could get a list of the <a href="https://en.wikipedia.org/wiki/List_of_cities_in_Australia_by_population">most populous cities</a> and just search the location text for the city name. Unfortunately city names are ambiguous, like Melbourne in both Victoria, Australia and Florida, USA. And it’s common for city names to be in street addresses like “Sydney Road”. But over a limited geographical region, like Australia, it’s an effective technique for not much effort.</p>
<p>This is in fact what Placeholder does, but with better rules for matching names and resolving ambiguity, and a much larger gazetteer called <a href="https://whosonfirst.org/"><em>Who’s on First</em></a>. It’s a really interesting <a href="https://whosonfirst.org/download/">open dataset</a>; it captures locations based on how people understand them and has a lot of information. There are a limited number of <a href="https://github.com/whosonfirst/whosonfirst-placetypes#here-is-a-pretty-picture">placetypes</a> like country and region, and they have names in multiple languages and associated coordinates and bounding regions in GeoJSON. It’s <a href="https://github.com/whosonfirst-data/whosonfirst-data/issues">continually evolving</a> as more open datasets get integrated and our notions of places change, like recently with <a href="https://en.wikipedia.org/wiki/North_Macedonia">North Macedonia</a> and <a href="https://en.wikipedia.org/wiki/South_Sudan">South Sudan</a>.</p>
<p>This adds real benefits because suburbs like “Macquarie Park” can be detected to be in Sydney, and it has an existing location hierarchy that can be used. The better rules mean it can distinguish an ambiguous place by “Mornington” if you also supply the state. Otherwise information can be used to better order the choices when it is ambiguous.</p>
</section>
<section id="placeholder-in-practice" class="level1">
<h1>Placeholder in Practice</h1>
<p>Understanding Who’s on First is helpful for understanding how Placeholder behaves. For example in Australia a <em>region</em> roughly corresponds to a state or territory, a <em>county</em> is like a <a href="https://en.wikipedia.org/wiki/Local_government_in_Australia">Local Government Area</a> and a <em>macrocounty</em> is like a greater city. For example Ryde is a county, in the macrocounty of Sydney in the region New South Wales.</p>
<p>However currently the concept of <a href="https://spelunker.whosonfirst.org/placetypes/macrocounty/">macrocounty</a> only exists in Australia and Germany. This is because the types of geographies people use depend on political structures, and Who’s on First is a living asset. Eventually there may be macrocounties in other countries, but the type of division to use has to depend on the context.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../images/wof_macrocounty.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">Macrocounties in Who’s on First</figcaption><p></p>
</figure>
</div>
<p>If I try to normalise “Sydney CBD, Australia” with placeholder I currently get the neighbourhood of <a href="https://spelunker.whosonfirst.org/id/85782343/">Melbourne CBD</a>. This is because “Sydney CBD” is not currently in Who’s on First, but “Melbourne CBD” is. Placeholder is pretty smart; adding more context like “Sydney CBD, NSW, Australia” gives <a href="https://spelunker.whosonfirst.org/id/101932003/">the locality of Sydney</a>.</p>
<p>I haven’t looked deeply how <a href="https://github.com/pelias/placeholder">Placeholder works</a> works yet, but the more context you give it the better it behaves. In particular for English it seems to prefer the location to go from specific to general. For example the top result for “Australia, Newcastle” is in <a href="https://spelunker.whosonfirst.org/id/101926669/">South Africa</a>, but “Newcastle, Australia” is in <a href="https://spelunker.whosonfirst.org/id/101931395/">Australia</a>.</p>
<p>To get better results when you have more context you can filter the results to the context. For example you could just filter to places in Australia by filtering on it’s What’s on First id.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>WOF_AUS_ID <span class="op">=</span> <span class="dv">85632793</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> place <span class="kw">in</span> places:</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> l <span class="kw">in</span> place[<span class="st">'lineage'</span>]:</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (<span class="st">'country'</span> <span class="kw">in</span> l <span class="kw">and</span> l[<span class="st">'country'</span>][<span class="st">'id'</span>] <span class="op">=</span> <span class="dv">85632793</span>):</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> place</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Finally Placeholder seems to be sensitive to tokens used. It seems to like vertical struts <code>|</code> and parentheses <code>()</code> confuse Placeholder. This is probably down to the tokenisation logic.</p>
</section>
<section id="putting-it-together" class="level1">
<h1>Putting it together</h1>
<p>Different websites have different conventions for storing location information. Rewriting the locations from specific to general, separated by commas with as much context as possible gets much beter results.</p>
<p>This requires writing slightly different rules for every website, but works very well in practice. If we wanted to improve the output we could look at better ways of filtering and ranking on relevant context, but for now it works well enough.</p>
<p>When working in Python running the Placeholder server means there’s a bit of extra setup; but it looks like with some care (and some time) it looks straightforward to port the logic to Python if we needed to make it easier to setup.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>