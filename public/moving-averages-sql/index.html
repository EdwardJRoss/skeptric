<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.251">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2020-03-27">

<title>skeptric - Moving Averages in SQL</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../favicon.ico" rel="icon">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">skeptric</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../about.html">About</a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/EdwardJRoss"><i class="bi bi-github" role="img">
</i> 
 </a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Moving Averages in SQL</h1>
  <div class="quarto-categories">
    <div class="quarto-category">sql</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">March 27, 2020</p>
    </div>
  </div>
    
  </div>
  

</header>

<p>Moving averages can help smooth out the noise to reveal the underlying signal in a dataset. As they lag behind the actual signal they tradeoff timeliness for increased precision in the underlying signal. You could use them for reporting metrics or for alerting in cases where it’s more important to be sure there is a change than it is to catch any change early. It’s typically better to have a 7 day moving average than weekly reporting for important metrics because you’ll see changes earlier. There are a few ways to implement this in SQL with different tradeoffs, and a few traps to avoid.</p>
<p>The simplest way is with by summing over a limited window, but you have to be careful about missing data. It’s possible to construct a window manually with multiple lags which can let you choose weights. Or finally you can use a self join which can handle missing data and flexible weighting. Depending on your situation and database it’s worth considering which one is best in terms of performance and simplicity.</p>
<p>My recommendation in general is to use a self-join with a weights table (<a href="https://dbfiddle.uk/?rdbms=postgres_11&amp;fiddle=c2db62742ff071c49c0ea6d7b8808f94">fiddle</a>):</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> pages.<span class="dt">date</span>,</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>       <span class="fu">max</span>(pages.pageviews) <span class="kw">as</span> pageviews,</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>       <span class="cf">CASE</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>       <span class="cf">WHEN</span> pages.<span class="dt">date</span> <span class="op">-</span> (<span class="kw">select</span> <span class="fu">min</span>(<span class="dt">date</span>) <span class="kw">from</span> pages) <span class="op">&gt;=</span> <span class="dv">2</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>       <span class="cf">THEN</span> <span class="fu">sum</span>(weight <span class="op">*</span> ma_pages.pageviews)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>       <span class="cf">END</span> <span class="kw">as</span> weighted_moving_average</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> pages</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">JOIN</span> pages <span class="kw">AS</span> ma_pages <span class="kw">ON</span> pages.<span class="dt">date</span> <span class="op">-</span> ma_pages.<span class="dt">date</span> <span class="kw">BETWEEN</span> <span class="dv">0</span> <span class="kw">AND</span> <span class="dv">2</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">JOIN</span> weights <span class="kw">ON</span> idx <span class="op">=</span> pages.<span class="dt">date</span> <span class="op">-</span> ma_pages.<span class="dt">date</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">GROUP</span> <span class="kw">BY</span> pages.<span class="dt">date</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> pages.<span class="dt">date</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The rest of the article will go through the options and how to work around comming issues with missing data and handling the first few rows properly.</p>
<section id="calculating-a-moving-average" class="level1">
<h1>Calculating a moving average</h1>
<p>Suppose you have the daily number of pageviews for a new website you’re developing. To remove some of the noise you want to calculate a 3 day moving average (although in real life 7 day would be better because it smooths out weekend effects). Here is an example of the output:</p>
<table class="table">
<thead>
<tr class="header">
<th>date</th>
<th>pageviews</th>
<th>moving_average</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2020-02-01</td>
<td>42</td>
<td>42</td>
</tr>
<tr class="even">
<td>2020-02-02</td>
<td>3</td>
<td>22.5</td>
</tr>
<tr class="odd">
<td>2020-02-03</td>
<td>216</td>
<td>87</td>
</tr>
<tr class="even">
<td>2020-02-04</td>
<td>186</td>
<td>135</td>
</tr>
<tr class="odd">
<td>2020-02-05</td>
<td>510</td>
<td>304</td>
</tr>
<tr class="even">
<td>2020-02-06</td>
<td>419</td>
<td>371.667</td>
</tr>
<tr class="odd">
<td>2020-02-07</td>
<td>64</td>
<td>331</td>
</tr>
<tr class="even">
<td>2020-02-09</td>
<td>230</td>
<td>98</td>
</tr>
</tbody>
</table>
<p>Look particularly at the first two rows where there’s not a full 3 day window and the last row where it comes after a missing date.</p>
<p>In practice you might be calculating this for different segments, or for different periods (like weekly/monthly/quarterly), but the overall approach will be the same.</p>
</section>
<section id="moving-window-frame" class="level1">
<h1>Moving window frame</h1>
<p>The easiest way is with a moving window frame; you might start with something like:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Don't do this if there might be missing dates</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="op">*</span>,</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>      <span class="fu">avg</span>(pageviews) <span class="kw">OVER</span> (</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">ORDER</span> <span class="kw">BY</span> <span class="dt">date</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">ROWS</span> <span class="kw">BETWEEN</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>          <span class="dv">2</span> <span class="kw">PRECEDING</span> <span class="kw">AND</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>          <span class="kw">CURRENT</span> <span class="kw">ROW</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>      ) <span class="kw">AS</span> moving_average</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> pages</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> <span class="dt">date</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Note that for an N day moving window you use <code>BETWEEN N-1 PRECEDING</code> in the frame clause.</p>
<p>However there’s a problem here: if you’ve got missing days then it’s going to grab extra data before the moving window. For example in our table above there’s no data for 2020-02-08 so the query above will get data from 2020-02-06 which is more than 3 days ago.</p>
<p>There’s a build in way to solve this using the <code>RANGE</code> clause rather than the <code>ROWS</code> clause. In databases that support this with dates, like <a href="https://www.postgresql.org/docs/11/sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS">PostgreSQL 11</a>, it’s easy to fix (<a href="https://dbfiddle.uk/?rdbms=postgres_11&amp;fiddle=5605072830420611fd222920f5123ed4">fiddle</a>).</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="op">*</span>,</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>      <span class="fu">avg</span>(pageviews) <span class="kw">OVER</span> (</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">ORDER</span> <span class="kw">BY</span> <span class="dt">date</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">RANGE</span> <span class="kw">BETWEEN</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>          <span class="st">'2 DAYS'</span> <span class="kw">PRECEDING</span> <span class="kw">AND</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>          <span class="kw">CURRENT</span> <span class="kw">ROW</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>      ) <span class="kw">AS</span> moving_average</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> pages</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> <span class="dt">date</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>However not many databases support this, but some others support integer ranges. You could use the relevant date functions to create a date offset index:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="op">*</span>,</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>      <span class="fu">avg</span>(pageviews) <span class="kw">OVER</span> (</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">ORDER</span> <span class="kw">BY</span> date_offset</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">RANGE</span> <span class="kw">BETWEEN</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>          <span class="dv">2</span> <span class="kw">PRECEDING</span> <span class="kw">AND</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>          <span class="kw">CURRENT</span> <span class="kw">ROW</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>      ) <span class="kw">AS</span> moving_average</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> (</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">SELECT</span> <span class="op">*</span>,</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>           <span class="dt">date</span> <span class="op">-</span> <span class="fu">min</span>(<span class="dt">date</span>) <span class="kw">AS</span> date_offset</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">FROM</span> pages</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>) <span class="kw">as</span> pages_offset</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> <span class="dt">date</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>However support for bounded <code>RANGE</code> is pretty weak in databases, so sometimes not even this is an option. Another drawback of the <code>RANGE</code> solution is we don’t have the moving average value for 2020-02-08, even though it will have a value. The remaining solution is to fill out the table so there’s a row for each date with 0 page views. The general strategy is to create another table that has every date between the maximum and minimum of the <code>pages</code> and coalesce pageviews with 0; how you do this is database dependent. Then you join this to the <code>pages</code> table and fill in the nulls with a <code>coalesce</code> (<a href="https://dbfiddle.uk/?rdbms=postgres_11&amp;fiddle=7d2c81513dd77d9d6dacc4e9b816602c">fiddle</a>).</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- PostgresSQL example</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="op">*</span>,</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>       <span class="fu">avg</span>(pageviews) <span class="kw">OVER</span> (</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>         <span class="kw">ORDER</span> <span class="kw">BY</span> <span class="dt">date</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>         <span class="kw">ROWS</span> <span class="kw">BETWEEN</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>           <span class="dv">2</span> <span class="kw">PRECEDING</span> <span class="kw">AND</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>           <span class="kw">CURRENT</span> <span class="kw">ROW</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>       ) <span class="kw">AS</span> moving_average</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- Generating a date table is database dependent</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> (</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> dates.<span class="dt">date</span>, <span class="fu">coalesce</span>(pageviews, <span class="dv">0</span>) <span class="kw">AS</span> pageviews</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> generate_series((<span class="kw">select</span> <span class="fu">min</span>(<span class="dt">date</span>) <span class="kw">from</span> pages),</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>                      (<span class="kw">select</span> <span class="fu">max</span>(<span class="dt">date</span>) <span class="kw">from</span> pages),</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>                      <span class="st">'1 day'</span>) <span class="kw">as</span> dates</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="kw">LEFT</span> <span class="kw">JOIN</span> pages <span class="kw">on</span> dates.<span class="dt">date</span> <span class="op">=</span> pages.<span class="dt">date</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>) <span class="kw">AS</span> pages_full</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> <span class="dt">date</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Note that if we were calculating the pageviews by segment we could just update the window function to be <code>OVER (PARTITON BY SEGMENT ORDER BY ...)</code>.</p>
<p>There’s a limitation with this approach; it’s not possible to do a weighted moving average.</p>
</section>
<section id="moving-averages-with-lag" class="level1">
<h1>Moving Averages with Lag</h1>
<p>Another way to do moving averages is by selecting the previous rows with the lag window function. This tends to be very verbose, but a benefit is you can choose weights for each point. A weighted moving average is useful because you can weight down further ago values to capture more of the trend, so the moving average does not lag the signal as much.</p>
<p>The solution with lag is straightforward, but <a href="https://dbfiddle.uk/?rdbms=postgres_11&amp;fiddle=6dd6f9102117afd1143161aa1f6a45fe">tedious</a> (especially if you need to make a 90 day moving window):</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Don't use with missing dates</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="op">*</span>,</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>      (pageviews <span class="op">+</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>       <span class="fu">LAG</span>(pageviews) <span class="kw">OVER</span> (<span class="kw">order</span> <span class="kw">by</span> <span class="dt">date</span>) <span class="op">+</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>       <span class="fu">LAG</span>(pageviews, <span class="dv">2</span>) <span class="kw">OVER</span> (<span class="kw">order</span> <span class="kw">by</span> <span class="dt">DATE</span>)) <span class="op">/</span> <span class="dv">3</span> <span class="kw">AS</span> moving_average</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> pages</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> <span class="dt">date</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The first two rows are null rather than the relevant average - depending on your application this may be more or less appropriate. More problematically if there are missing dates then it will get the wrong result like our first <code>ROWS</code> query. It’s possible to work around this by throwing away data outside the date window (<a href="https://dbfiddle.uk/?rdbms=postgres_11&amp;fiddle=14a545b36a79b566a9bb3824a19165e0">fiddle</a>):</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="op">*</span>,</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>      (pageviews <span class="op">+</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>       (<span class="cf">CASE</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">WHEN</span> (<span class="dt">date</span> <span class="op">-</span> <span class="fu">LAG</span>(<span class="dt">date</span>) <span class="kw">OVER</span> (<span class="kw">order</span> <span class="kw">by</span> <span class="dt">date</span>)) <span class="op">&lt;=</span> <span class="dv">2</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">THEN</span> <span class="dv">1</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">ELSE</span> <span class="dv">0</span> <span class="cf">END</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>       ) <span class="op">*</span> <span class="fu">LAG</span>(pageviews) <span class="kw">OVER</span> (<span class="kw">order</span> <span class="kw">by</span> <span class="dt">date</span>) <span class="op">+</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>       (<span class="cf">CASE</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">WHEN</span> (<span class="dt">date</span> <span class="op">-</span> <span class="fu">LAG</span>(<span class="dt">date</span>, <span class="dv">2</span>) <span class="kw">OVER</span> (<span class="kw">order</span> <span class="kw">by</span> <span class="dt">date</span>)) <span class="op">&lt;=</span> <span class="dv">2</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">THEN</span> <span class="dv">1</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">ELSE</span> <span class="dv">0</span> <span class="cf">END</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>       ) <span class="op">*</span> <span class="fu">LAG</span>(pageviews, <span class="dv">2</span>) <span class="kw">OVER</span> (<span class="kw">order</span> <span class="kw">by</span> <span class="dt">DATE</span>)) <span class="op">/</span> <span class="dv">3</span> <span class="kw">AS</span> moving_average</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> pages</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> <span class="dt">date</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>However as in the previous section the best solution is probably to join it with a full date table if there may be missing dates (<a href="https://dbfiddle.uk/?rdbms=postgres_11&amp;fiddle=777ac73c01dcedf508b53f456f1dd300">fiddle</a>):</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="op">*</span>,</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>      (pageviews <span class="op">+</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>       <span class="fu">LAG</span>(pageviews) <span class="kw">OVER</span> (<span class="kw">order</span> <span class="kw">by</span> <span class="dt">date</span>) <span class="op">+</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>       <span class="fu">LAG</span>(pageviews, <span class="dv">2</span>) <span class="kw">OVER</span> (<span class="kw">order</span> <span class="kw">by</span> <span class="dt">DATE</span>)) <span class="op">/</span> <span class="dv">3</span> <span class="kw">AS</span> moving_average</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> (</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> dates.<span class="dt">date</span>, <span class="fu">coalesce</span>(pageviews, <span class="dv">0</span>) <span class="kw">AS</span> pageviews</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> generate_series((<span class="kw">select</span> <span class="fu">min</span>(<span class="dt">date</span>) <span class="kw">from</span> pages),</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>                      (<span class="kw">select</span> <span class="fu">max</span>(<span class="dt">date</span>) <span class="kw">from</span> pages),</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>                      <span class="st">'1 day'</span>) <span class="kw">as</span> dates</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="kw">LEFT</span> <span class="kw">JOIN</span> pages <span class="kw">on</span> dates.<span class="dt">date</span> <span class="op">=</span> pages.<span class="dt">date</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>) <span class="kw">AS</span> pages_full</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> <span class="dt">date</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="adding-weights" class="level2">
<h2 class="anchored" data-anchor-id="adding-weights">Adding weights</h2>
<p>Because we’re manually writing each part of the moving average it’s possible to add weights; say we wanted to use the weights (0.6, 0.24, 0.16) to emphasise the more recent data points. It’s as simple as inserting the weights into the query:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="op">*</span>,</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>      <span class="fl">0.6</span> <span class="op">*</span> pageviews <span class="op">+</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>      <span class="fl">0.24</span> <span class="op">*</span> <span class="fu">LAG</span>(pageviews) <span class="kw">OVER</span> (<span class="kw">order</span> <span class="kw">by</span> <span class="dt">date</span>) <span class="op">+</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>      <span class="fl">0.16</span> <span class="op">*</span> <span class="fu">LAG</span>(pageviews, <span class="dv">2</span>) <span class="kw">OVER</span> (<span class="kw">order</span> <span class="kw">by</span> <span class="dt">DATE</span>) <span class="kw">AS</span> weighted_moving_average</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> (</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> dates.<span class="dt">date</span>, <span class="fu">coalesce</span>(pageviews, <span class="dv">0</span>) <span class="kw">AS</span> pageviews</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> generate_series((<span class="kw">select</span> <span class="fu">min</span>(<span class="dt">date</span>) <span class="kw">from</span> pages),</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>                      (<span class="kw">select</span> <span class="fu">max</span>(<span class="dt">date</span>) <span class="kw">from</span> pages),</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>                      <span class="st">'1 day'</span>) <span class="kw">as</span> dates</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="kw">LEFT</span> <span class="kw">JOIN</span> pages <span class="kw">on</span> dates.<span class="dt">date</span> <span class="op">=</span> pages.<span class="dt">date</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>) <span class="kw">AS</span> pages_full</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> <span class="dt">date</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The lag approach is simple and should work in any database that supports window functions. As before we can do it per segment using <code>PARTITION BY</code> in the window clause. However writing each lag is tedious for large windows, which the next approach solves.</p>
</section>
</section>
<section id="moving-averages-with-self-joins" class="level1">
<h1>Moving Averages with Self Joins</h1>
<p>Using self joins is in some senses the simplest, most reliable and versatile. Not every SQL database supports window functions, but they should support JOIN. However you may opt for one of the other options for performance reasons, or for convenience in a quick analysis.</p>
<p>The basic approach is to join the table to itself over the range of dates; this looks really similar to the <code>RANGE</code> window (<a href="https://dbfiddle.uk/?rdbms=postgres_11&amp;fiddle=098e3726d2503941b94b288332a65d85">fiddle</a>)</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Only use if doesn't have missing data</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> pages.<span class="dt">date</span>,</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>      <span class="fu">max</span>(pages.pageviews) <span class="kw">as</span> pageviews,</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>      <span class="fu">avg</span>(ma_pages.pageviews) <span class="kw">as</span> moving_average</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> pages</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="kw">JOIN</span> pages <span class="kw">AS</span> ma_pages <span class="kw">ON</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>       pages.<span class="dt">date</span> <span class="op">-</span> ma_pages.<span class="dt">date</span> <span class="kw">BETWEEN</span> <span class="dv">0</span> <span class="kw">AND</span> <span class="dv">2</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="kw">GROUP</span> <span class="kw">BY</span> pages.<span class="dt">date</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> pages.<span class="dt">date</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>However again missing dates make the result incorrect. In our example for 2020-02-09 the denominator for the average is 2 (because there’s no row for 2020-02-10). As before we can fix this by inserting 0 pageviews for the missing days (<a href="Fiddle:%20https://dbfiddle.uk/?rdbms=postgres_11&amp;fiddle=b4ee2028eba4d6adbd7a2518c02d2bc3">fiddle</a>).</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> pages.<span class="dt">date</span>,</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>      <span class="fu">max</span>(pages.pageviews) <span class="kw">as</span> pageviews,</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>      <span class="fu">avg</span>(ma_pages.pageviews) <span class="kw">as</span> moving_average</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> (</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> dates.<span class="dt">date</span>, <span class="fu">coalesce</span>(pageviews, <span class="dv">0</span>) <span class="kw">AS</span> pageviews</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> generate_series((<span class="kw">select</span> <span class="fu">min</span>(<span class="dt">date</span>) <span class="kw">from</span> pages),</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>                      (<span class="kw">select</span> <span class="fu">max</span>(<span class="dt">date</span>) <span class="kw">from</span> pages),</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>                      <span class="st">'1 day'</span>) <span class="kw">as</span> dates</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="kw">LEFT</span> <span class="kw">JOIN</span> pages <span class="kw">on</span> dates.<span class="dt">date</span> <span class="op">=</span> pages.<span class="dt">date</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>) <span class="kw">AS</span> pages</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="kw">LEFT</span> <span class="kw">JOIN</span> (</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> dates.<span class="dt">date</span>, <span class="fu">coalesce</span>(pageviews, <span class="dv">0</span>) <span class="kw">AS</span> pageviews</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> generate_series((<span class="kw">select</span> <span class="fu">min</span>(<span class="dt">date</span>) <span class="kw">from</span> pages),</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>                      (<span class="kw">select</span> <span class="fu">max</span>(<span class="dt">date</span>) <span class="kw">from</span> pages),</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>                      <span class="st">'1 day'</span>) <span class="kw">as</span> dates</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a><span class="kw">LEFT</span> <span class="kw">JOIN</span> pages <span class="kw">on</span> dates.<span class="dt">date</span> <span class="op">=</span> pages.<span class="dt">date</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>) <span class="kw">AS</span> ma_pages <span class="kw">ON</span> pages.<span class="dt">date</span> <span class="op">-</span> ma_pages.<span class="dt">date</span> <span class="kw">BETWEEN</span> <span class="dv">0</span> <span class="kw">AND</span> <span class="dv">2</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a><span class="kw">GROUP</span> <span class="kw">BY</span> pages.<span class="dt">date</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> pages.<span class="dt">date</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>However there’s another way we can fix this by using weights.</p>
<section id="weighted-moving-average" class="level2">
<h2 class="anchored" data-anchor-id="weighted-moving-average">Weighted moving average</h2>
<p>To calculate the weighted moving average we can store the weights in a separate table. For example if we want the most recent data point to have a weight of 0.6, the middle point a weight of 0.24 and the furthest point a weight of 0.16 we could have a table like this:</p>
<table class="table">
<thead>
<tr class="header">
<th>idx</th>
<th>weight</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0.6</td>
</tr>
<tr class="even">
<td>1</td>
<td>0.24</td>
</tr>
<tr class="odd">
<td>2</td>
<td>0.16</td>
</tr>
</tbody>
</table>
<p>Not that we could reproduce the moving average by having a table with each weight being equal and adding to 1</p>
<table class="table">
<thead>
<tr class="header">
<th>idx</th>
<th>weight</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0.333</td>
</tr>
<tr class="even">
<td>1</td>
<td>0.333</td>
</tr>
<tr class="odd">
<td>2</td>
<td>0.333</td>
</tr>
</tbody>
</table>
<p>We then join the weight based on the number of steps from the current date and calculate the inner product. Note that we censor the first two rows with a CASE statement, otherwise they will be wrong (<a href="https://dbfiddle.uk/?rdbms=postgres_11&amp;fiddle=9f0f1adcfac53da4829be234b88ca3b4">fiddle</a>).</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> pages.<span class="dt">date</span>,</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>       <span class="fu">max</span>(pages.pageviews) <span class="kw">as</span> pageviews,</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>       <span class="cf">CASE</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>       <span class="cf">WHEN</span> pages.<span class="dt">date</span> <span class="op">-</span> (<span class="kw">select</span> <span class="fu">min</span>(<span class="dt">date</span>) <span class="kw">from</span> pages) <span class="op">&gt;=</span> <span class="dv">2</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>       <span class="cf">THEN</span> <span class="fu">sum</span>(weight <span class="op">*</span> ma_pages.pageviews)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>       <span class="cf">END</span> <span class="kw">as</span> weighted_moving_average</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> pages</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="kw">JOIN</span> pages <span class="kw">AS</span> ma_pages <span class="kw">ON</span> pages.<span class="dt">date</span> <span class="op">-</span> ma_pages.<span class="dt">date</span> <span class="kw">BETWEEN</span> <span class="dv">0</span> <span class="kw">AND</span> <span class="dv">2</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="kw">JOIN</span> weights <span class="kw">ON</span> idx <span class="op">=</span> pages.<span class="dt">date</span> <span class="op">-</span> ma_pages.<span class="dt">date</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="kw">GROUP</span> <span class="kw">BY</span> pages.<span class="dt">date</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> pages.<span class="dt">date</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The best part about this is it works even if there’s a missing date. However you do lose the data point for the missing date, so you may want to complete the table if you know there’s missing dates. If we wanted to have partial results for the first 2 days we’d need to renormalise the weights based on the number of days since the first. The only limitation to this method is you’ll need a way to create the weights table. But even if you don’t have access to creating (temporary) tables, you may be able to do this using a <a href="https://www.postgresql.org/docs/12/queries-values.html">select from values</a> (<a href="https://dbfiddle.uk/?rdbms=postgres_11&amp;fiddle=55f87d80bd3244904519841e5dae69b7">fiddle</a>).</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> pages.<span class="dt">date</span>,</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>       <span class="fu">max</span>(pages.pageviews) <span class="kw">as</span> pageviews,</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>       <span class="cf">CASE</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>       <span class="cf">WHEN</span> pages.<span class="dt">date</span> <span class="op">-</span> (<span class="kw">select</span> <span class="fu">min</span>(<span class="dt">date</span>) <span class="kw">from</span> pages) <span class="op">&gt;=</span> <span class="dv">2</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>       <span class="cf">THEN</span> <span class="fu">sum</span>(weight <span class="op">*</span> ma_pages.pageviews)</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>       <span class="cf">END</span> <span class="kw">as</span> weighted_moving_average</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> pages</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="kw">JOIN</span> pages <span class="kw">AS</span> ma_pages <span class="kw">ON</span> pages.<span class="dt">date</span> <span class="op">-</span> ma_pages.<span class="dt">date</span> <span class="kw">BETWEEN</span> <span class="dv">0</span> <span class="kw">AND</span> <span class="dv">2</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="kw">JOIN</span> (<span class="kw">SELECT</span> idx, <span class="dv">1</span><span class="op">/</span>(<span class="dv">2</span> <span class="op">+</span> <span class="fl">1.</span>) <span class="kw">as</span> weight <span class="kw">FROM</span> (<span class="kw">VALUES</span> (<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>)) <span class="kw">as</span> t(idx)) weights <span class="kw">ON</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>  idx <span class="op">=</span> pages.<span class="dt">date</span> <span class="op">-</span> ma_pages.<span class="dt">date</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="kw">GROUP</span> <span class="kw">BY</span> pages.<span class="dt">date</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> pages.<span class="dt">date</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Now you know a few ways to create moving averages and how to avoid the most common pitfalls regarding missing data and the initial rows. The weight table is the safest and most flexible solution and you could even create standard weight tables to use accross multiple metrics. However sometimes you’ll want to use the framed window method for performance or convenience methods (or the lag method if you also need weighting).</p>
<p>Happy querying!</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>