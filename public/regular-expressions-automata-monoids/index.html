<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.251">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2013-09-03">

<title>skeptric - Regular expressions, automata and monoids</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../favicon.ico" rel="icon">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">skeptric</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../about.html">About</a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/EdwardJRoss"><i class="bi bi-github" role="img">
</i> 
 </a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Regular expressions, automata and monoids</h1>
</div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">September 3, 2013</p>
    </div>
  </div>
    
  </div>
  

</header>

<p>In <a href="https://en.wikipedia.org/wiki/Formal_language">formal language theory</a> the task is to specify, over some given alphabet, a set of valid strings. This is useful in searching for structures textual data through files (e.g.&nbsp;via <a href="https://en.wikipedia.org/wiki/Grep">grep</a>), for specifying the syntactic structure of programming languages (e.g.&nbsp;in <a href="https://en.wikipedia.org/wiki/GNU_bison">Bison</a> or <a href="http://johnmacfarlane.net/pandoc/">pandoc</a>), and for generating output of a specified form (e.g.&nbsp;automatic <a href="http://pdos.csail.mit.edu/scigen/">computer science</a> and <a href="http://thatsmathematics.com/mathgen/">mathematics</a> paper generators).</p>
<p>An <a href="https://en.wikipedia.org/wiki/Automata_theory">automoton</a> is (roughly) a set of symbols, and a set of states, along with transitions for each state that take a symbol and return another state. They can be used to model (and verify) simple processes.</p>
<p>Automata can be brought into correspondence with formal languages in a very natural way; given an initial state s, and a sequence of symbols (a1, a2, …, an) the automata has a naturally assigned state (… ((s a1) a2) … an) (where “(state symbol)” represents the state obtained from the transition on symbol using state). Then if we nominate an initial state, and a set of “accepting” valid states, we say a string is in the language of the automata if and only if when applied to the initial state it ends in a final state.</p>
<p>This gives a very useful pairing in computer science; formal languages are useful tools, and automata (often) give an efficient way to implement them on a computer.</p>
<!--more-->
<p>To get a little more mathematical a <a href="https://en.wikipedia.org/wiki/Semigroup">semigroup</a> is a a closed associative binary operation; if we add a two sided identity it is called a <a href="https://en.wikipedia.org/wiki/Monoid">monoid</a>, and if we additionally add inverses it becomes a group. For instance under addition the set of positive numbers (1, 2, …) is a semigroup, the set of non-negative numbers is a monoid with identity 0, and the set of integers is a group with -a being the inverse of a. Clearly every group is a monoid (forgetting about the inverses) and every monoid is a semigroup (forgetting about the identity).</p>
<p>In the same way a group often arises as a set of invertible transformations (isomorphisms), a monoid often arises as a set of transformations (morphisms). Another useful example of a monoid is sets under union, with 0 corresponding to the empty set.</p>
<p>The <a href="https://en.wikipedia.org/wiki/Free_monoid">free monoid</a> generated by a set S, denoted S*, is the set of all (finite or infinite) sequences of elements of S with multiplication defined as concatenation.</p>
<p>For example {x}* has set <span class="math inline">\(\{\epsilon, x, xx, xxx, xxxx, \ldots\} = \{x^0, x^1, x^2, x^3, x^4, \ldots \}\)</span> (where <span class="math inline">\(\epsilon\)</span> represents the sequence with no elements), and multiplication is given by <span class="math inline">\(x^n x^m = x^{n+m}\)</span> . As a further example some elements of {x, y}* are <span class="math inline">\(\epsilon\)</span> , x, y, xx, xy, yx, yy, xxx, xxy, xyx, yxx, xyy, yxy, yyx, yyy, …</p>
<p>In computer science terms the free monoid generated by the set S is precisely the set of all strings (or words) in the alphabet S, with the monoid product corresponding to string concatenation.</p>
<p>Using this notation a language over a finite set S is a subset of S*; that is an element of the power set <span class="math inline">\(2^{S*}\)</span> . More generally we can define a language over a monoid, M, as an element of the power set of M.</p>
<p>There is a natural product on the power set of a monoid; <span class="math inline">\(AB \equiv \{ab | a \in A, b \in B\}\)</span> , and so it too is a monoid with identity <span class="math inline">\(\{\epsilon\}\)</span> . There is another natural monoidal structure on any collection of subsets; union with the additive identity of the empty set. Notice that <span class="math inline">\(A (B \cup C) = (AB) \cup (AC)\)</span> and similarly <span class="math inline">\((A \cup B) C = (AC) \cup (BC)\)</span> , and <span class="math inline">\(\emptyset A = \emptyset = A \emptyset\)</span> . Consequently the power set of a monoid naturally has the structure of a <a href="https://en.wikipedia.org/wiki/Semiring">semiring</a>.</p>
<p>Given a subset S of a monoid M, denote S* (the Kleene star) to be its monoidal closure; the smallest submonoid of M containing S. The regular expressions over a set (alphabet) Σ is defined to be the set generated by the elements <span class="math inline">\(\{\epsilon\}, \{a\}, a \in \Sigma\)</span> using the <a href="https://en.wikipedia.org/wiki/Kleene_algebra">Kleene algebra</a> formed by the semiring <span class="math inline">\(2^M\)</span> with the Kleene star.</p>
<p>On the other hand a <a href="https://en.wikipedia.org/wiki/Deterministic_finite_automaton">deterministic finite automoton</a> (DFA) over a set (alphabet) Σ is a finite set of states S, an initial state s in S, a subset F of accepting states of S, and a transition map <span class="math inline">\(t : S \times \Sigma \to S\)</span> . The language of a DFA is the set of all strings (a b … x) of symbols in Σ such that <span class="math inline">\(t( \cdots t( t(s, a), b) \cdots , x) \in F\)</span> . Often a DFA is represented diagrammatically using circles to represent states, and labelled arrows to represent the transitions between states [this looks rather like a category theory diagram]. The initial state is denoted by a horizontal arrow pointing to it, and the final states are represented by a double circle.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../images/DFAexample.svg" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">An example DFA Diagram</figcaption><p></p>
</figure>
</div>
<p>In the example above the alphabet is {0, 1} the states are {S1, S2}, the initial state is S1, and the final states are {S1}, the transitions are t(S1, 0) = S2, t(S1, 1) = S1, t(S2, 1) = S2, t(S2, 0) = S1.</p>
<p>Often the transitions are represented as a <a href="https://en.wikipedia.org/wiki/State_transition_table">table</a> with states listed vertically and transitions listed horizontally e.g.</p>

<table border="1" cellpadding="1" cellspacing="0" width="410">
<tbody>
<tr>
<td>
</td>
<td>
<b>0</b>
</td>
<td>
<b>1</b>
</td>
</tr>
<tr>
<td>
<b><i>S</i><sub>1</sub></b>
</td>
<td>
<i>S</i><sub>2</sub>
</td>
<td>
<i>S</i><sub>1</sub>
</td>
</tr>
<tr>
<td>
<b><i>S</i><sub>2</sub></b>
</td>
<td>
<i>S</i><sub>1</sub>
</td>
<td>
<i>S</i><sub>2</sub>
</td>
</tr>
</tbody>

</table>
<p>More algebraically we can consider the transition to be the monoidal action; since the elements of Σ generate Σ* freely, the transition extends uniquely to a function <span class="math inline">\(T : S \times \Sigma* \to S\)</span> such that T(t, xy) = T(T(t, x), y) for any state t and elements of Σ* x and y.</p>
<p>Rephrasing and generalising slightly, a DFA over a monoid M is a set of states S, a (contravariant) monoid homomorphism <span class="math inline">\(\rho : M \to \hbox{Map}(S)\)</span> (where Map(S) represents all functions from S to S; i.e.&nbsp;<span class="math inline">\(\rho(xy) = \rho(y) \rho(x)\)</span> ), an initial state s from S, and a subset F of accepting states in S. Then the language of a DFA is precisely <span class="math inline">\(L = \{ x \in M | \rho(x) \circ s \in F\}\)</span> .</p>
<p>Theorem: The regular languages are equivalent to the languages representable by a DFA.</p>
<p>This theorem can be proved as follows: a DFA is inductively transformed into a regular expression by transforming the DFA that can only pass through an increasingly large subset of states. A regular expression is transformed into a nondeterministic finite automoton, which is in turn transformed into a DFA.</p>
<p>A <a href="https://en.wikipedia.org/wiki/Nondeterministic_finite_automaton">nondeterministic finite automaton</a> (NFA) over a set Σ is a set S, an initial state s, a set of accepting states F and a transition map t <span class="math inline">\(S \times \Sigma \to 2^S\)</span> . Then a string (a b … c) is in the language of the NFA if and only if there is some <span class="math inline">\(s_1 \in t(s, a), s_2 \in t(s_1, b), ... s_n \in t(s_{n-1}, c)\)</span> such that <span class="math inline">\(s_n \in F\)</span> .</p>
<p>Sometimes epsilon transitions are allowed; that is transitions that take no input so t <span class="math inline">\(S \times \Sigma \cup \{\epsilon\} \to 2^S\)</span> , and we allow arbitrary epsilon insertions in the string. As with DFAs, NFAs can be represented diagrammatically and implemented efficiently as a table (though in this case we need to trace every possible path of a transition).</p>
<p>These can be extended more algebraically as follows: a NFA over a monoid M is a set S, a set of initial states I, a set of accepting states F, and a monoid/semigroup homomorphism <span class="math inline">\(\rho : M \to 2^S\)</span> . The language of an NFA is <span class="math inline">\(\{x \in M | \rho(x) \circ I \cap F \neq \emptyset \}\)</span> . (The previous definition is simply M = Σ*, I = {s} and <span class="math inline">\(\rho(x) \circ A = \bigcup_{a \in A} t(x, a)\)</span> ).</p>
<p>The monoidal case corresponds to no epsilon transitions, and the semigroup case allows monoidal transitions (for then <span class="math inline">\(\rho(\epsilon)\)</span> need not be the identity). To promote a semigroup homomorphism ρ to a monoidal homomorphism η we simply define <span class="math inline">\(\eta(x) = \rho(x) \rho(\epsilon)^*\)</span> (considering <span class="math inline">\(2^S\)</span> as a Kleene algebra in the obvious way).</p>
<p>It is almost trivial to represent a given NFA as a DFA; we take the set of the DFA to be <span class="math inline">\(2^S\)</span> , the initial state to be S, the final states to be any state intersecting F, and the transition function to be the same. This is the so called power-set construction.</p>
<p>So DFA=NFA=Regular Languages.</p>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>