<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.251">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2022-05-11">

<title>skeptric - Point-in-time joins and real time feature stores</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../favicon.ico" rel="icon">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">skeptric</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../about.html">About</a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/EdwardJRoss"><i class="bi bi-github" role="img">
</i> 
 </a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Point-in-time joins and real time feature stores</h1>
  <div class="quarto-categories">
    <div class="quarto-category">sql</div>
    <div class="quarto-category">data</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">May 11, 2022</p>
    </div>
  </div>
    
  </div>
  

</header>

<p>Going from batch processing to near-real time applications is a big conceptual leap for data scientists. Data scientists are often familiar with big SQL analytics databases and can run a batch process weekly or daily. However to get good performance in some applications requires aggregating information that changes more quickly than batch processes can handle. There is normally some lag time between an event being processed and being ingested into an analytics database (and this lag time can vary across the data) which limits the batch approach. A near-real time approach, where the data is up to date between milliseconds and minutes, requries a suitable way to store and retrieve the data in a low latency way. This data store can be called an online feature store; it contains the <em>features</em>, or inputs, for the model and is updated live.</p>
<p>When we’ve got an online feature store we need to be careful that we don’t use it to train and evaluate new models. We want the data <em>as it would have been when the prediction was made</em>, this means we need to record all the results in an offline analytics store. However if we change the features of the model we want to use the current version of the features, not the version at the time the prediction was made. Let’s illustrate this with an example.</p>
<p>Consider a recommendation system for articles on this website. On each article we are going to recommend 3 other articles to suggest, to help the reader find other relevant content. Using our historical logs we see that looking at the previous page viewed can lead to substantially better recommendations than just using the current page viewed. In particular we build a model that extracts key terms from the previous page viewed and the current page viewed, then these are used to form a query to return relevant pages from a database. However our logs are only updated daily and people tend to view pages within minutes of each other, so we need a way of storing the information.</p>
<p>We create a PostgreSQL database to track all our state; we could use any other number of key-value stores but as it’s a standard database it may be more familiar to Data Scientists. We have a table <code>articles</code> for articles and their keywords which we update whenever a new article is published.</p>
<table class="table">
<colgroup>
<col style="width: 14%">
<col style="width: 25%">
<col style="width: 15%">
<col style="width: 44%">
</colgroup>
<thead>
<tr class="header">
<th>article_id</th>
<th>article_name</th>
<th>update_time</th>
<th>keywords</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>Point-in-time joins</td>
<td>2022-04-01</td>
<td>[“sql”,“python”,“machine-learning”]</td>
</tr>
<tr class="even">
<td>2</td>
<td>Recipe NER</td>
<td>2022-03-01</td>
<td>[“python”,“nlp”]</td>
</tr>
</tbody>
</table>
<p>And another table <code>activity</code> for tracking user activity which collects events from the frontend:</p>
<table class="table">
<thead>
<tr class="header">
<th>user_id</th>
<th>event_time</th>
<th>article_id</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>2022-05-11T11:00:00Z</td>
<td>1</td>
</tr>
<tr class="even">
<td>1</td>
<td>2022-05-11T11:05:00Z</td>
<td>2</td>
</tr>
<tr class="odd">
<td>2</td>
<td>2022-05-11T11:00:00Z</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>Then we can get get out the keywords with an SQL query, which we use to recommend articles:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> history.<span class="op">*</span>,</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>       articles.keywords <span class="op">||</span> last_articles.keywords <span class="kw">AS</span> keywords</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">SELECT</span> user_id,</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>          event_time,</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>          activity.article_id,</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>          <span class="fu">lag</span>(article_id) <span class="kw">OVER</span> (<span class="kw">PARTITION</span> <span class="kw">BY</span> user_id</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>                                <span class="kw">ORDER</span> <span class="kw">BY</span> event_time) <span class="kw">AS</span> last_article_id,</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>                               <span class="fu">row_number</span>() <span class="kw">OVER</span> (<span class="kw">PARTITION</span> <span class="kw">BY</span> user_id</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>                                                  <span class="kw">ORDER</span> <span class="kw">BY</span> event_time <span class="kw">DESC</span>) <span class="kw">AS</span> user_row_number</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>   <span class="kw">FROM</span> activity) <span class="kw">AS</span> history</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="kw">LEFT</span> <span class="kw">JOIN</span> articles <span class="kw">ON</span> history.article_id <span class="op">=</span> articles.article_id</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="kw">LEFT</span> <span class="kw">JOIN</span> articles <span class="kw">AS</span> last_articles <span class="kw">ON</span> history.last_article_id <span class="op">=</span> last_articles.article_id</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="kw">WHERE</span> user_row_number <span class="op">=</span> <span class="dv">1</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<table class="table">
<colgroup>
<col style="width: 7%">
<col style="width: 19%">
<col style="width: 10%">
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 32%">
</colgroup>
<thead>
<tr class="header">
<th>user_id</th>
<th>event_time</th>
<th>article_id</th>
<th>last_article_id</th>
<th>user_row_number</th>
<th>keywords</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>2022-05-11T11:07:00Z</td>
<td>3</td>
<td>2</td>
<td>1</td>
<td>[“python”,“nlp”,“sql”,“python”,“machine-learning”]</td>
</tr>
<tr class="even">
<td>2</td>
<td>2022-05-11T11:00:00Z</td>
<td>1</td>
<td>null</td>
<td>1</td>
<td>[“sql”,“python”,“machine-learning”]</td>
</tr>
</tbody>
</table>
<p>This works, but we find as the activity table grows the queries are getting slow and the recommendations are taking minutes to load. Also when we are training a model on this database the recommendations get even slower again. Instead we create a <code>current_activity</code> table that only carries the current snapshot of the data needed to generate the recommendations. To keep it very fast we send and update the keywords on the fly:</p>
<table class="table">
<colgroup>
<col style="width: 6%">
<col style="width: 16%">
<col style="width: 8%">
<col style="width: 12%">
<col style="width: 27%">
<col style="width: 27%">
</colgroup>
<thead>
<tr class="header">
<th>user_id</th>
<th>event_time</th>
<th>article_id</th>
<th>last_article_id</th>
<th>current_keywords</th>
<th>last_keywords</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>2022-05-11T11:07:00Z</td>
<td>3</td>
<td>2</td>
<td>[“python”,“nlp”]</td>
<td>[“sql”,“python”,“machine-learning”]</td>
</tr>
<tr class="even">
<td>2</td>
<td>2022-05-11T11:00:00Z</td>
<td>1</td>
<td>null</td>
<td>[“sql”,“python”,“machine-learning”]</td>
<td>null</td>
</tr>
</tbody>
</table>
<p>But from the <code>current_activity</code> table we can’t evaluate the historical recommendations. Whenever a new page is viewed it UPDATEs the row for that user and we lose the history. So we set up <a href="https://datacater.io/blog/2021-09-02/postgresql-cdc-complete-guide.html">Change Data Capture</a> to track all the changes and store it in a separate analytics database. We then have a <code>historical_activity</code> table that contains the state of the activity every time.</p>
<p>We think that a better keyword extraction strategy could produce better recommendations. When training and evaluating on historical data we want to use our new keyword feature, not the one that was available at the time. Otherwise we’re not testing the model on the same data we will have at inference time, we have training-serving skew. This means we can’t use the keywords from the <code>historical_activity</code>, but have to lookup the new keywords using <code>article_id</code> and <code>last_article_id</code>. So we add a new <code>keywords_v2</code> column and use a variation of the SQL query above to get the new features. An alternative would be to add <code>keywords_v2</code> to the live feature store and wait for historical data to accumulate, but this is a very slow way to iterate on features.</p>
<p>However we actually rewrote the point-in-time joins article to use Julia instead of Python. When recommending to people who viewed the old version we should use the keywords based on the text of that article; presumably they were more interested in Python. To do this we need to do a <em>point-in-time join</em>; we join with the <code>article</code> table containing all versions and get the most recent version available at that time. We do that by joining on <code>event_time &gt;= update_time</code> and then pick the row with the most recent <code>update_time</code>. It’s a bit more complex because we need to do this for the previous version as well; here’s an SQL query that may do it.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode sql code-with-copy"><code class="sourceCode sql"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="op">*</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">SELECT</span> history.<span class="op">*</span>,</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>          articles.keywords_v2 <span class="op">||</span> last_articles.keywords_v2 <span class="kw">AS</span> keywords,</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>          <span class="fu">row_number</span>() <span class="kw">OVER</span> (<span class="kw">PARTITION</span> <span class="kw">BY</span> user_id,</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>                                          event_time,</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>                                          history.article_id,</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>                                          history.last_article_id</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>                             <span class="kw">ORDER</span> <span class="kw">BY</span> articles.update_time <span class="kw">DESC</span>, last_articles.update_time <span class="kw">DESC</span>) <span class="kw">AS</span> rn</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>   <span class="kw">FROM</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>     (<span class="kw">SELECT</span> user_id,</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>             event_time,</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>             activity.article_id,</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>             <span class="fu">lag</span>(article_id) <span class="kw">OVER</span> (<span class="kw">PARTITION</span> <span class="kw">BY</span> user_id</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>                                   <span class="kw">ORDER</span> <span class="kw">BY</span> event_time) <span class="kw">AS</span> last_article_id,</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>                                  <span class="fu">lag</span>(event_time) <span class="kw">OVER</span> (<span class="kw">PARTITION</span> <span class="kw">BY</span> user_id</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>                                                        <span class="kw">ORDER</span> <span class="kw">BY</span> event_time) <span class="kw">AS</span> last_article_event_time,</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>                                                       <span class="fu">row_number</span>() <span class="kw">OVER</span> (<span class="kw">PARTITION</span> <span class="kw">BY</span> user_id</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>                                                                          <span class="kw">ORDER</span> <span class="kw">BY</span> event_time <span class="kw">DESC</span>) <span class="kw">AS</span> user_row_number</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>      <span class="kw">FROM</span> activity) <span class="kw">AS</span> history</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>   <span class="kw">LEFT</span> <span class="kw">JOIN</span> articles <span class="kw">ON</span> history.article_id <span class="op">=</span> articles.article_id</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>   <span class="kw">AND</span> history.event_time <span class="op">&gt;=</span> articles.update_time</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>   <span class="kw">LEFT</span> <span class="kw">JOIN</span> articles <span class="kw">AS</span> last_articles <span class="kw">ON</span> history.last_article_id <span class="op">=</span> last_articles.article_id</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>   <span class="kw">AND</span> history.last_article_event_time <span class="op">&gt;=</span> last_articles.update_time</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>   <span class="kw">WHERE</span> user_row_number <span class="op">=</span> <span class="dv">1</span> ) all_versions</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a><span class="kw">WHERE</span> rn <span class="op">=</span> <span class="dv">1</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This substantially improves our offline metrics. We take the latest version of <code>keyword_v2</code> for all users, insert it into our online feature store, and run an A/B experiment to see whether it is really better.</p>
<p>In summary we want to get the data as it would have been if the new features were used at that time. For the <em>raw data</em>, such as the interaction events and article text, we want to get the data as it was at interaction time. If this involves combining data between historical tables we need to do a <em>point-in-time join</em> to get the correct data. For the <em>features</em> that are built on the raw data, such as keywords, we want to calculate them as they are now. This becomes very clear when you think about brand new features, such as using a the location of the user or a dense embedding of the articles instead of keywords. This lets us do offline evaluation of new features in a faithful way.</p>
<p>In practice it may make sense to use various approximations to make this process computationally tractable. We can truncate the update times (e.g.&nbsp;to the hour or the day) which can create fewer potential join points if there are multiple updates. We can also limit the updates to some window if articles become stale and expire. Any offline evaluation itself requries approximation, we don’t know how a user would really react to a different set of recommendations, so these are generally acceptable.</p>
<section id="how-do-feature-stores-do-it" class="level1">
<h1>How do feature stores do it?</h1>
<p>This hopefully illustrates the kinds of problems that feature stores try to solve. Here are a few examples of point-in-time joins in different feature stores:</p>
<ul>
<li><a href="https://docs.feast.dev/getting-started/concepts/point-in-time-joins">Feast</a> looks like it snapshots features at regular intervals and only retains them over some window (in the diagram feature_hourly_stats only has aggregate stats on the hour they set a <code>ttl=timedelta(hours=2)</code>)</li>
<li><a href="https://examples.hopsworks.ai/master/featurestore/hsfs/time_travel/point_in_time_join_python/">Hopsworks</a> looks like it generates SparkSQL to do the point-in-time join (join on a.key = b.key and a.time &lt;= b.time), I think over a limited time window</li>
<li><a href="https://aws.amazon.com/blogs/machine-learning/build-accurate-ml-training-datasets-using-point-in-time-queries-with-amazon-sagemaker-feature-store-and-apache-spark/">Sagemaker</a> makes you roll your own point-in-time join and windowing manually</li>
<li><a href="https://featuretools.alteryx.com/en/stable/getting_started/handling_time.html">Featuretools</a> (not a feature store) has an informative discussion of the different approaches (windowing, approximating, windowing)</li>
</ul>
<p>Doing this manually, especially from SQL, can be very error prone (I wouldn’t be surprised if the query above is wrong). In general the features may need to represent different kinds of joins and aggregations (for example maybe we want the last 3 referral sources for a user). If you need to do this kind of point-in-time join you should try to automate it, and make the process of generating features for model training/evaluation and at inference time as similar as possible. This can be tricky because the performance characteristics are quite different, at training time you want to generate features on a very large amount of data with high throughput, but at inference time you want to generate features on a single datum with low latency. Having a strategy that lets you do both is important for making these kinds of features practicable.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>