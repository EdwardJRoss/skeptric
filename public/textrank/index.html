<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.251">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2022-02-09">

<title>skeptric - TextRank</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../favicon.ico" rel="icon">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">skeptric</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../about.html">About</a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/EdwardJRoss"><i class="bi bi-github" role="img">
</i> 
 </a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">TextRank</h1>
  <div class="quarto-categories">
    <div class="quarto-category">nlp</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">February 9, 2022</p>
    </div>
  </div>
    
  </div>
  

</header>

<p><a href="https://web.eecs.umich.edu/~mihalcea/papers/mihalcea.emnlp04.pdf">TextRank</a> (Mihalecea and Tarau, 2004) is the idea of using graph ranking algorithms, like <a href="http://ilpubs.stanford.edu:8090/422/1/1999-66.pdf">PageRank</a>, as an unsupurvised way of extracting key units of text from a document. The interesting part is how they define graphs on the units of text; filtering text units (e.g.&nbsp;words, sentences) to obtain a set of vertices, and using proximity or similarity measures for defining a graph. They specifically look at the applications of keyword extraction and summarisation. This is a really useful and versatile idea; and although it requires application specific tuning, is a valuable tool in the unsupervised text toolkit.</p>
<p>The first application is extracting keywords from 500 abstracts of papers from Inspec (scientific and technical papers). The original dataset was from Hulth’s 2003 paper <a href="https://aclanthology.org/W03-1028.pdf">Improved Automatic Keyword Extraction Given More Linguistic Knowledge</a>, and the dataset is on the web (e.g.&nbsp;<a href="https://github.com/LIAAD/KeywordExtractor-Datasets#Inspec">here</a>, <a href="https://github.com/boudinfl/ake-datasets/tree/master/datasets/Inspec">here</a> and <a href="https://github.com/SDuari/Keyword-Extraction-Datasets">here</a>). It consists of small abstracts and human annotated key phrases. Their TextRank approach is to:</p>
<ol type="1">
<li>filter the tokens of the abstract to just nouns and adjectives as the vertices</li>
<li>form a co-occurance graph (unweighted, undirected) based on window of size 2</li>
<li>using PageRank to rank the vertices</li>
<li>filtering to the top 1/3 of vertices by rank</li>
<li>combining any adjacent words in the filtered vertices to get key phrases</li>
</ol>
<p>This works quite well for this dataset, although there’s a lot of choices in here that I suspect are specific to the dataset and task. The algorithm looks for dense clusters of keywords, and frequent keywords, and this does much better than just frequent keywords alone. With all this tuning (which unfortunately sounds like it was done on the test set), they get something that works better in terms of precision and F1 than Hulth’s supervised approach.</p>
<p>The second application is text summarisation, based on the <a href="https://www-nlpir.nist.gov/projects/duc/guidelines/2002.html">Document Understanding Conference 2002 task</a> (which you have to <a href="https://www-nlpir.nist.gov/projects/duc/data.html">request access for</a>. It consists of news articles and manually generated abstracts. Their approach is to extract <em>key sentences</em> by forming a weighted graph of the sentences based on textual similarity between the sentences, rank the sentences using weighted PageRank, and limit the summary by length. The particular similarity they use is the number of tokens in common, divided by the sum of log lengths of the sentences (perhaps a cousin of Jaccard Distance).</p>
<p><span class="math display">\[{\rm Similarity}(S_i, S_j) = \frac{\left \vert S_i \cap S_j \right \vert}{\log(\vert S_i \vert) + \log(\vert S_j \vert)}\]</span></p>
<p>In terms of <a href="https://en.wikipedia.org/wiki/ROUGE_(metric)">ROUGE-1</a> it ranks about middle of the systems submitted; which is pretty impressive given the simplicity. In the example it seems to work well because the subject is in the title line and repeated in the most relevant sentences.</p>
<p>These particular TextRank algorithms are available in software; in R there is <a href="https://cran.r-project.org/web/packages/textrank/vignettes/textrank.html">textrank</a> which covers both tasks, and in Python textacy has <a href="https://textacy.readthedocs.io/en/0.11.0/api_reference/extract.html#module-textacy.extract.keyterms.textrank">keyword extraction</a> and gensim has textrank <a href="https://radimrehurek.com/gensim_3.8.3/summarization/summariser.html">summarisation</a>.</p>
<p>The real innovation here isn’t the particular approaches used, but the idea of using existing graph ranking algorithms for text extraction problems. There are a large and growing number of ways to find similarity between text units (for example sentence embeddings and contextual embeddings), other behavioural sources of graph information from interactions with documents, and a large number of graph algorithms. These could be combined in a multitude of ways to solve problems where the information to be extracted is likely to be threaded throughout a document. Being unsupervised, and able to work on any scale from characters all the way to entire books, makes it a versatile tool.</p>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>