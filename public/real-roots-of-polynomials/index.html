<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.251">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2013-04-30">

<title>skeptric - Algorithms for finding the real roots of polynomials</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../favicon.ico" rel="icon">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">skeptric</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../about.html">About</a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/EdwardJRoss"><i class="bi bi-github" role="img">
</i> 
 </a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Algorithms for finding the real roots of polynomials</h1>
  <div class="quarto-categories">
    <div class="quarto-category">maths</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">April 30, 2013</p>
    </div>
  </div>
    
  </div>
  

</header>

<p>Given an degree n polynomial over the real numbers we are guaranteed there are at most n real roots by the fundamental theorem of algebra; but how do we find them? Here we explore the Vincent-Collins-Akritas algorithm.</p>
<p>It uses <a href="http://en.wikipedia.org/wiki/Descartes%27_rule_of_signs"><strong>Descartes’ rule of signs</strong></a>: given a polynomial <span class="math inline">\(p(x) = a_n x^n + \cdots + a_1 x + a_0\)</span> the number of real positive roots (counting multiplicites) is bounded above by the number of <em>sign variations</em> in the sequence <span class="math inline">\((a_n, \ldots, a_1, a_0)\)</span> .</p>
<!--more-->
<p>So as an example <span class="math inline">\(p(x) = x^2 - 1\)</span> has a sequence of coefficients <span class="math inline">\((1, 0, -1)\)</span> which contains 1 sign change (we ignore zeros), and so has at most one positive root; in fact we know it has exactly one positive root 1. On the other hand the bound is necessary: <span class="math inline">\(p(x) = (x-(1+i))(x-(1-i))= x^2-2x+2\)</span> has 2 sign changes, but no positive real roots.</p>
<p>Descartes’ theorem tells us about the number of zeros of a degree n polynomial <span class="math inline">\(p(x)\)</span> on the open interval <span class="math inline">\((0, \infty)\)</span> ; what if we wanted to know about the number of zeros on some other interval <span class="math inline">\((u, v)\)</span> ? We could perform a <strong>projective transformation</strong> <span class="math inline">\(f(x) = \frac{a x + b}{c x + d}\)</span> ( <span class="math inline">\(ad - bc \neq 0\)</span> ); in order to still have a polynomial we need to multiply out the denominator to get <span class="math inline">\(q(x) = (cx+d)^{n} p(\frac{ax +b}{cx+d})\)</span> . The positive zeros of q(x) are the positive zeros of <span class="math inline">\((cx+d)^n\)</span> and the zeros of p(x) between <span class="math inline">\(-\frac{b}{a}\)</span> and <span class="math inline">\(-\frac{d}{c}\)</span> . In particular if we choose a=u, b=v, c=1, d=1 the number of positive zeros of q(x) is precisely the number of zeros of p(x) in the interval <span class="math inline">\((u, v)\)</span> .</p>
<p>By the rule of signs if q(x) has zero sign variations then p(x) has no root in <span class="math inline">\((u, v)\)</span> . This leads to our <strong>iterative bisection strategy</strong> for finding the zeros of a polynomial on an interval. Given a sequence of intervals bisect each interval and find the sign variations of the polynomial projected on each subinterval; if it is zero then discard it, otherwise add it to the next sequence of intervals. This yields a sequence of intervals which may contain zeros of p.&nbsp;However we don’t know which intervals contain no zeros or multiple zeros.</p>
<p>Consider the case of one sign variation; for sufficiently small x, p(x) will have the sign of the terms at the end of the sequence (towards the constant term), and for sufficiently large x, p(x) will have the sign of the leading term. Consequently, since these signs are opposite, by the <a href="http://en.wikipedia.org/wiki/Intermediate_value_theorem">intermediate value theorem</a> there exists a positive real x such that p(x) is zero. By Descartes’ rule of signs there is at most one real zero; hence there must be exactly one real zero.</p>
<p>Hence we can adjust our algorithm; if there is one sign variation then we add it to a list of definite zeros. However we’re still not sure that the intervals not containing zero will be eliminated; we need a sort-of converse to Descartes’ theorem.</p>
<p>This converse is given by a pair of theorems due to <strong>Obreshkoff</strong>: Given a degree n polynomial p(x)</p>
<ul>
<li>If p(x) has least p complex zeros with arguments in the range <span class="math inline">\(- \frac{\pi}{n + 2 - p} &lt; \phi &lt; \frac{\pi}{n+2-p}\)</span> then the number of sign variations is bounded above by p.</li>
<li>If p(x) has at least n-q complex zeros with arguments in range <span class="math inline">\(\pi - \frac{\pi}{q + 2} \leq \phi \leq \pi + \frac{\pi}{q + 2}\)</span> then the number of sign variations is bounded below by q.</li>
</ul>
<p>When we translate this by a projective transformation we get a picture like this (taken from <a href="http://scidok.sulb.uni-saarland.de/volltexte/2010/3244/pdf/Dissertation_8200_Eige_Arno_2008.pdf">Arno Eigenwillig’s thesis</a>)</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../images/obreshkoffarc.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">Obreshkoff Arc for n=8 and p=q=2</figcaption><p></p>
</figure>
</div>
<p>If p(x) has at least p roots in <span class="math inline">\(OL_{\geq}\)</span> above, then the transformed sign variations are bounded above by p.&nbsp;If p(x) has at most q roots in <span class="math inline">\(OL_{\leq}\)</span> above then the transformed sign variations are bounded below by q.</p>
<p>Essentially the sign variations can only see zeros “nearby” within these arcs. Since these arcs get smaller as the interval gets smaller it is guaranteed that for sufficiently small intervals (depending on the distance between the roots of the polynomial) the number of sign variations will equal the number of roots.</p>
<p>In particular if all the real roots are <strong>simple</strong> then the bisection process above will eventually terminate; all intervals will eventually have zero sign variations (in which case there are no roots) or one sign variation (in which case they contain a root).</p>
<p>Hence we have an algorithm for isolating the distinct real roots of a polynomial p(x) over the integers on a bounded interval I.</p>
<ol type="1">
<li>Remove all multiple roots by dividing p(x) by the greatest common divisor of p and its derivative.</li>
<li>The last interval list is {I}, the next interval list is {} and the roots are {}</li>
<li>Remove each interval from the last interval list, bisect it then add it to the last interval list.</li>
<li>For each interval in the last interval list calculate the sign variations: if it’s 0 discard it, if it’s 1 add it to the roots, otherwise add it to the next interval list</li>
<li>If the next interval list is empty return the roots, otherwise set the last interval list to the next interval list, the next interval list to {} and goto 3.</li>
</ol>
<p>It’s worth noting that transforming the polynomial can be done just with the operations multiply by two, divide by two and add (see <a href="http://sci-gems.math.bas.bg/jspui/bitstream/10525/376/1/sjc051-vol2-num1-2008.pdf">On the Various Bisection Methods Derived From Vincents Theorem</a>).</p>
<p>Why just the integers? Polynomials over the rationals can be solved by the same method, by first factoring out the denominators. The real numbers are much more subtle: we can’t calculate the gcd, and worse we can’t even necessarily calculate the sign of a coefficient! (I mean in an algorithmic manner; c.f. <a href="http://en.wikipedia.org/wiki/Richardson%27s_theorem">Richardson’s Theorem</a>).</p>
<p>One excellent thing about this is the intervals are guaranteed to contain exactly one root; we can then use something like the bisection method to find the zeros to any desired accuracy.</p>
<p>I haven’t been sufficiently precise with my algorithm to analyse it, but there are implementations that use <span class="math inline">\(O(n^6t^2log^2_nn)\)</span> binary operations on polynomials of degree n on integer t bit coefficients.</p>
<p>There are, of course, other methods of finding all the roots of a real polynomial; but few of them are global and stable like this one. (Though <a href="http://mathlab.sunysb.edu/~scott/Papers/Newton/Published.pdf">a variation of Newton’s method</a> isn’t a bad candidate, albeit without precise bounds).</p>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>